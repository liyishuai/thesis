A tester consists of a validator and a test harness.  Chapters~\ref{chap:theory}
and \ref{chap:practices} have explained the validator's theory and practices.
This chapter presents a language-based design for test harnesses.  I'll show how
to generate and shrink test inputs effectively, addressing inter-execution
nondeterminism.

\autoref{sec:harness-overview} provides a brief overview of how test harnesses
work.  \autoref{sec:heuristics} explains how to write heuristics to generate
interesting test inputs.  \autoref{sec:shrinking} then shows how to keep the
test inputs interesting among different executions in the shrinking process.

\section{Overview}
\label{sec:harness-overview}
\input{overview}

\section{Heuristics for Test Generation}
\label{sec:heuristics}
\input{heuristics}

\section{Shrinking Interactive Tests}
\label{sec:shrinking}
\input{shrink}

\lys{Under construction:}

The IR in this framework is JSON, which allows syntax trees to be arbitrarily
wide and deep, and provides sufficient flexibility for network protocols in
general.  The J-expression is an extension of JSON that can refer to specific
fields in the trace:

The extended syntax
``$\Jref{\mathit{label}}{\mathsf{Jpath}}{\mathit{function}}$'' is a symbolic
expression that, given a runtime trace, can compute an IR of the request.  For
example, J-expression
``$\Jref{3}{\This\At\mathtt{"orders"}\Number2}{\mathtt{id}}$'' can be
pronounced: ``Look at the message labelled 3 in the trace, its `order' field
should be an array.  Find the 2nd element in that array, and use it
\ilc{id}entically (as-is).''  Such representation enables the test harness to
shrink counterexamples (encoded in Jexp) in a protocol-independent way.


\begin{figure}
  \begin{lstlisting}[style=customcoq]
    Example response1 : http_response :=
      Response (Status (Version 1 1) 200 (Some "OK"))
               [Field "ETag" "tag-foo";
                Field "Content-Length" "11"]
               (Some "content-bar").

    Example response2 : store_response :=
      Response__ListOrders [(233, (12, 100, 34, 500));
                            (996, (56, 400, 78, 20))].
  \end{lstlisting}
  \begin{minipage}[t]{.4\textwidth}
    \begin{lstlisting}[style=json]
      {
        "version": {
          "major": 1,
          "minor": 1
        },
        "code": 200,
        "reason": "OK",
        "fields": {
          "ETag": "tag-foo",
          "Content-Length": "11"
        },
        "body": "content-bar"
      }
    \end{lstlisting}
  \end{minipage}%
  \begin{minipage}[t]{.4\textwidth}
    \begin{lstlisting}[style=json]
      {
        "code": 200,
        "orders": [
          {
            "ID": 233,
            "BuyerID": 12,
            "BuyAmount": 100,
            "SellerID": 34,
            "SellAmount": 500
          },
          {
            "ID": 996,
            "BuyerID": 56,
            "BuyAmount": 400,
            "SellerID": 78,
            "SellAmount": 20
          }
        ]
      }
    \end{lstlisting}
  \end{minipage}
  \caption{Application message example for HTTP and online store protocols, and
    their corresponding intermediate representation}
  \label{fig:ir}
\end{figure}

To represent the correspondence between requests and responses, the trace labels
each message, and the request-response pair have the same label.
\autoref{fig:trace} shows a trace of messages sent and received by the tester
client.

\begin{figure}
  \begin{minipage}{.5\textwidth}
    \begin{lstlisting}[style=json]
      [
        {
          "label": 10,
          "message": {
            "method": "GET",
            "path": "index.html"
          }
        },
        {
          "label": 20,
          "message": {
            "method": "DELETE",
            "path": "index.html"
          }
        },
        {
          "label": 20,
          "message": {
            "code": 204,
            "reason": "No Content",
          }
        },
        {
          "label": 10,
          "message": {
            "code": 410,
            "reason": "Gone"
          }
        }
      ]
    \end{lstlisting}
  \end{minipage}%
  \begin{minipage}{.5\textwidth}
    \includegraphics[width=\textwidth]{figures/trace}
  \end{minipage}
  \caption{Example client-side trace and its corresponding IR}
  \label{fig:trace}
\end{figure}

\section{Instantiating requests during runtime}
To instantiate a Jexp into request IR, the test harness substitutes all
occurences of ``$\Jref{\mathit{label}}{\mathsf{Jpath}}{\mathit{function}}$''
with its corresponding IR computed from the trace.  However, due to external
nondeterminism, the expected message label might be delayed and not available in
the trace.  Also, considering inter-execution nondeterminism, arrays in observed
messages might not have enough elements as expected in the Jexp.  In these
cases, the test harness searches for other labels in the trace and other
elements in the arrays as a fallback fulfillment to construct the request.

\lys{Todo: add instantiation algorithm.}

This idea of shrinking symbolic representations can be applied to scenarios
beyond networked servers.  For example, the HTTP testing experiment in
\autoref{sec:eval} has also used this technique to locate the bug pattern.
