The area of automated testing is well-studied, diverse, and difficult to
navigate~\cite{anand2013orchestrated}.  This chapter explores methodologies in
specifying and testing interactive systems.  I focus on techniques that have
been practised in testing real-world programs.

This chapter partitions the techniques by the languages used for writing the
specifications, which are motivated by the challenges posed in various testing
scenarios.

\section{State machine specification: Quviq QuickCheck}
\citet{testing-dropbox} have tested Dropbox, by specifying the synchronizer as a
stateful program.  Their specification focuses on a single file being editted
and synchronized among multiple nodes, while I specify the semantics for
synchronizing directories with tree structure.

To address external nondeterminism, they introduce {\em conjectured events} to
specify that local nodes may communicate with the server at any time.  My
network model design in \autoref{sec:external-nondet} was inspired by this idea
of conjecturing the environment's behavior.

Property-based testing with QuickCheck has been well adopted in industrial
practices~\cite{Hughes2016}.  This paper extends QuickCheck in two dimensions:
(i) To specify systems' nondeterministic behavior in a reasonable way, I
designed a generic modelling language to describe ``how to produce valid
behavior'', which is then automatically interpreted into properties that ``what
behavior is valid''; (ii) To minimalize counterexamples and locate bugs, I
introduced a protocol-independent representation of test input, which allows
reproducing trace-based heuristics among different executions.

\section{Process algebra: LOTOS and TorXakis}
Language of Termporal Ordering Specification (LOTOS)~\cite{lotos} is the ISO
standard for specifying OSI protocols.  It defines distributed concurrent
systems as {\em processes} that interact via {\em channels}.  Using a formal
language strongly inspired by LOTOS, \citet{torxakis-dropbox} implemented a test
generation tool called TorXakis, and used it for testing Dropbox.

TorXakis supports internal nondeterminism by defining a process for each
possible value.  This requires the space of invisible values to be finite.  In
comparison, I represented invisible values as symbolic variables, and employed
constraint solving that can handle inifitite space of data like strings and
integers.

As for external nondeterminism, TorXakis hardcodes all channels between each
pair of processes, assuming no new process joins the system.  Whereas in my
network model, ``channels'' are the ``source'' and ``destination'' fields of
network packets, which allows specifying a server that exposes its port to
infinitely many clients.

\section{Transition systems: NetSem and Modbat}
Using labelled transition systems (LTS), \citet{netsem} have developed rigorous
specification for TCP, UDP, and the Sockets API.  To handle internal
nondeterminism in real-world implementations, they symbolized the model states,
which is then evaluated with a special-purpose model symbolic model checker.
They focused on developing a post-hoc specification that matches mainstream
systems like FreeBSD, Linux, and WinXP, while I aim at finding bugs in rapidly
evolving implementations, and borrowed the idea of symbolic evaluation in
validating observations.

\citet{modbat} have generated test cases for Java network API, which involves
blocking and non-blocking communications.  Their abstract model was based on
extended finite state machines (EFSM), and could capture bugs in the network
library \verb|java.nio|.  Their validator rejects the SUT upon unexpected
exceptions or observations that fail its {\em encoded} assertions.  In
comparison, assertions in my validator are {\em derived} from the abstract
model, which covers full functional correctness of the SUT.
