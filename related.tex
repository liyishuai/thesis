The area of automated testing is well-studied, diverse, and difficult to
navigate~\cite{anand2013orchestrated}.  This chapter explores methodologies in
specifying and testing interactive systems.  I focus on techniques that have
been practised in testing real-world programs.  \autoref{sec:related-validate}
compares different specification techniques and their derived validators.
\autoref{sec:related-harness} then discusses practices in developing test
harnesses.

\section{From Specification to Validators}
\label{sec:related-validate}

Different testing scenarios exhibit various challenges that motivate the
specification design.  This section partitions the validation techniques by the
languages used for developing the specifications.

\subsection{State machine specification: Quviq QuickCheck}
Property-based testing with QuickCheck has been well adopted in industrial
contexts~\cite{Hughes2016}.  The specification is a boolean function over traces
{\it i.e.} the validator.  My solutions to addressing internal and external
nondeterminism are inspired by practices in QuickCheck.

\paragraph{Internal nondeterminism}
My \http specification was initially written as a QuickCheck property.  Before
handling preconditions like \inlinec{If-Match} and \inlinec{If-None-Match}, the
validator implements a deterministic server model and compares its behavior with
the observations, as shown in the \ilc{validate} function in
\autoref{sec:interactive-testing}.  When expanding the specification to cover
conditional requests, I implemented the ad hoc validator by manually translating
the trace into tester-side knowledge, as shown in \autoref{fig:etag-tester}.

The complexity in describing ``what behavior is valid'' motivates me to rephrase
the specification.  I applied the idea of model-based
testing~\cite{broy2005model}, and specified the protocol in terms of ``how to
produce valid behavior''.  My specification represented internal nondeterminism
with symbolic variables.  The validator then checks whether the trace is
producible by the symbolic specification, by reducing the producibility problem
to constraint solving.

\paragraph{External nondeterminism}
\citet{testing-dropbox} have used QuickCheck to test Dropbox.  The specification
does not involve internal nondeterminism, but does handle external
nondeterminism that local nodes may communicate with the server at any time.
This is done by introducing ``conjectured events'' to represent the possible
communications.  The validator checks if the conjectured events can be inserted
to somewhere in the trace to make it producible by the model.

To specify servers' allowed observations delayed by the network, \citet{cpp19}
introduced the concept of ``network refinement''.  The network may scramble the
traces by delaying some messages after others, with one exception: If the client
has received response \ilc A before it sends request \ilc Q, then by causality,
the server-side trace must have sent response \ilc A before receiving request
\ilc Q.  Upon observing a client-side trace \ilc T, our QuickCheck validator
searches for a server-side trace that (i) can be reasonably scrambled into trace
\ilc T, and (ii) complies with the protocol specification.

My network model design in \autoref{sec:external-nondet} was inspired by these
idea of conjecturing the environment's behavior.  Instead of inserting
conjectured communication events or reordering the trace, I specified the
network as an independent module and composed it with the server specification.
This provides more flexibility in specifying the environment {\it e.g.} limiting
the buffer size or the number of concurrent connections, and allows reusing the
network models for specifying other protocols on top of it.

\subsection{Process algebra: LOTOS and TorXakis}
Language of Termporal Ordering Specification (LOTOS)~\cite{lotos} is the ISO
standard for specifying OSI protocols.  It defines distributed concurrent
systems as {\em processes} that interact via {\em channels}.  Using a formal
language strongly inspired by LOTOS, \citet{torxakis-dropbox} implemented a test
generation tool called TorXakis, and used it for testing Dropbox.

TorXakis supports internal nondeterminism by defining a process for each
possible value.  This requires the space of invisible values to be finite.  In
comparison, I represented invisible values as symbolic variables, and employed
constraint solving that can handle inifitite space of data like strings and
integers.

As for external nondeterminism, TorXakis hardcodes all channels between each
pair of processes, assuming no new process joins the system.  Whereas in my
network model, ``channels'' are the ``source'' and ``destination'' fields of
network packets, which allows specifying a server that exposes its port to
infinitely many clients.

\subsection{Transition systems: NetSem and Modbat}
Using labelled transition systems (LTS), \citet{netsem} have developed rigorous
specification for TCP, UDP, and the Sockets API.  To handle internal
nondeterminism in real-world implementations, they symbolized the model states,
which is then evaluated with a special-purpose model symbolic model checker.
They focused on developing a post-hoc specification that matches mainstream
systems like FreeBSD, Linux, and WinXP, while I aim at finding bugs in rapidly
evolving implementations, and borrowed the idea of symbolic evaluation in
validating observations.

\citet{modbat} have generated test cases for Java network API, which involves
blocking and non-blocking communications.  Their abstract model was based on
extended finite state machines (EFSM), and could capture bugs in the network
library \verb|java.nio|.  Their validator rejects the SUT upon unexpected
exceptions or observations that fail its {\em encoded} assertions.  In
comparison, assertions in my validator are {\em derived} from the abstract
model, which covers full functional correctness of the SUT.

\section{Test Harnesses}
\label{sec:related-harness}
In this section,

This paper extends QuickCheck in two dimensions:
(i) To specify systems' nondeterministic behavior in a reasonable way, I
designed a generic modelling language to describe ``how to produce valid
behavior'', which is then automatically interpreted into properties that ``what
behavior is valid''; (ii) To minimalize counterexamples and locate bugs, I
introduced a protocol-independent representation of test input, which allows
reproducing trace-based heuristics among different executions.
