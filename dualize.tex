So far we have defined the QAC language family, where specifications and
validators are represented as state monads.  This section will show how to
derive validators from the specification.

\subsection{Encoding specifications and validators}
To write an algorithm from the specification to the validator, we need to
analyze the computations defined by the specification's model program.  The QAC
language family only provides a state monad interface, which is not destructable
by itself.  We need to introduce a programming language to represent the
specification, and derive validators by interpreting programs written in that
language.

\begin{definition}[Server and validator of a program]
  A program $p\in\Prog$ is a representation of computation that can be
  ``instantiated'' into a server model:
  \[\serverOf:\Prog\to\Server\]
  
  A program can also be ``interpreted'' into other computations, including
  validators:
  \[\validatorOf:\Prog\to\Validator\]
\end{definition}
To encode specifications for protocols like CMP-RST, we introduce a simple
$\Prog$ language, which supports arithmetic operations and memory access:
\[\begin{array}{lrll}
\Prog&\triangleq&\Return&\text{end computation and send response}\\
&\mid&!dst\coloneqq\Sexp;\Prog&\text{write to address }dst\in\Nat\\\null
&\mid&\If\Sexp\le\Sexp\Then\Prog\Else\Prog&\text{conditional branch}\\
\Sexp&\triangleq&\Int&\text{constant integer}\\
&\mid&!src&\text{read from address }src\in\Nat\\
&\mid&\Sexp\;op\;\Sexp&op\in\{+,-,\times,\div\}
\end{array}
\]

Servers specified in this $\Prog$ language are defined as follows:
\begin{enumerate}
\item The server state is a key-value mapping, where the keys are natural
  numbers, and the values are integers.
\item The initial server state maps all keys to zero:
  \[\serverOf(p)\triangleq\existT{S}{\Nat\to\Int}{(\sstep_p,(\_\mapsto0))}\]
\item The server's query, response, and choices ($Q$, $A$, $C$) are all
  natural numbers.
\item At the beginning of each server loop, the query is written to address
  $!0$, and the internal choice is written to address $!1$.
\item After writing the query and response, the server $\Exec$utes the $\Prog$
  model, which manipulates the key-value store.
\item When the $\Prog$ model $\Return$s, the server sends back the value stored
  in address $!0$ as the response.
\end{enumerate}
Let $p\in\Prog$ be the model program, then the server's loop body $\sstep_p$ is
defined as:
\[\begin{array}{lrl}
\sstep_p(q,c,s_0)&\triangleq&\letin{s_1}{\update{s_0}{1}{c}}\\
&&\letin{s_2}{\update{s_1}{0}{q}}\\
&&\letin{s_3}{\Exec(p,s_2)}\\
&&(s_3!0,s_3)\\
\Exec(p,s)&\triangleq&
\begin{cases}
  s&p\Is\Return\\
  \Exec(p',\update{s}{dst}{e^s})&p\Is !dst\coloneqq e;p'\\
  \Exec(\If {e_1}^s\le{e_2}^s\Then p_1\Else p_2,s)&p\Is\If e_1\le e_2\Then p_1\Else p_2
\end{cases}\\
e^s&\triangleq&
\begin{cases}
  z&e\Is z:\Int\\
  s!src&e\Is !src\\
  {e_1}^s\;op\;{e_2}^s&e\Is e_1\;op\;e_2
\end{cases}
\end{array}\]
Here ``$e^s$'' is pronounced ``evaluating expression $e$ with state $s$''.  It
substitutes all occurences of ``$!src$'' to the value stored at address $src$ of
mapping $s$, written as ``$s!src$''.  ``$s[k\mapsto v]$'' is pronounced
``updating mapping $s$ at address $k$ to value $v$''.  It produces a new state
where $k$ is mapped to $v$, while other addresses remain unchanged from $s$:
\[s[k\mapsto v]!k'\triangleq\begin{cases}v&k'=k\\
s!k'&k'\neq k\end{cases}\]

To specify protocols with this $\Prog$ language, the model program should read
the query from address $!0$, and parameterize the space of nondeterministic
behavior over the internal choice in address $!1$.  When the model program
returns, it should have stored the computed response in address $!0$.  Addresses
greater than $!1$ are only writable by the specification, and can be used for
storing the server state.

For example, the CMP-RST specification in \autoref{sec:qac} can be written in
$\Prog$ as:
\[\begin{array}{ll}
\If !0\equiv0\Then !2\coloneqq!1;\Return&(1)\\
\eelse\If !0\equiv!2\Then!0\coloneqq1;\Return&(2)\\
\eelse!0\coloneqq0;\Return&(3)
\end{array}\]
Here ``$\If e_1\equiv e_2\Then p_1\Else p_2$'' is a syntactic sugar for:
\[\If e_1\le e_2\Then(\If e_2\le e_1\Then p_1\Else p_2)\Else p_2\]
When the query is zero (case 1), the nondeterministic value is stored in address
$!2$, and compared against later non-zero queries.  Address $!0$ is untouched,
so the server echoes the zero request back as response.

For non-zero queries (cases 2 and 3), the server checks whether the request is
equal to the value stored in address $!2$, and stores the corresponding response
to address $!0$.

This $\Prog$ language features arithmetic operations, conditional branches,
memory access, and internal nondeterminism.  It also exhibits a tree structure
that allows inductive reasoning.  The rest of this section derives validators
from $\Prog$ models, and prove the correctness of such derived validators.

\subsection{Dualize model program into validator}
The validator of a model $p\in\Prog$ needs to determine whether the trace is
producible by $p$.  More specifically, whether the responses in the trace can be
{\em explained} by $p$'s return value stored at address $!0$.

The idea is similar to \ilc{tester} in \autoref{sec:interactive-testing}, which
\ilc{validate}s the trace by executing the \ilc{serverSpec}, and comparing the
expected response against the tester's observation.

However, when the specification is nondeterministic, the expectation of response
$A$ is parameterized over the internal choice $C$.  Therefore, the validator
should determine whether there exists such $C$ that led the specification to
produce the observed $A$.

This reduces the trace validation problem to constraint solving.  Upon observing
a response, the validator adds a constraint that the observation can be
explained by running the specification with certain value of choices.

More specifically, the validator executes the $\Prog$ model and represents
internal choices with {\em symbolic variables}.  These variables are carried
along the program execution, so the expected responses are computed as {\em
  symbolic expressions} that might depend on those variables.  The validator
then constraints that the symbolic response is equal to the concrete
observation.

To achieve this goal, the validator needs to store the symbolic expression for
each address of the server model.  It also needs to remember all the constraints
added upon observation.  We store these information as ``validation states'':
\[(\Nat\to\Vexp)\times\Set\constraint\]
Here the $\constraint$s are relations between validator expressions ($\Vexp$s)
that may depend on symbolic $\Var$iables:
\[\begin{array}{lrl@{\qquad}l}
\constraint&\triangleq&\Vexp\;cmp\;\Vexp&cmp\in\{<,\le,\equiv\}\\
\Vexp&\triangleq&\Int&\text{constant integer}\\
&\mid&\#x&\text{variable }x\in\Var\\
&\mid&\Vexp\;op\;\Vexp&op\in\{+,-,\times,\div\}\\
\end{array}\]

In practice, we use an equivalent definition for the validator state:
\[(\Nat\to\Var)\times\Set\constraint\]
The key-expression mapping $(k\mapsto e)$ above can be simulated with the
key-variable $(k\mapsto x)$ mapping here, by adding $(\#x\equiv e)$ to the set
of constraints.  We alter the type interface for convenience of developing the
validator, which will be later explained in more details.

Notice that the internal choices might affect branch conditions, so the
validator doesn't know which branch in the specification was taken.  Therefore,
it should maintain multiple validation states, one for each possible execution
path of the specification:
\[\Set((\Nat\to\Var)\times\Set\constraint)\]

The initial state of the validator is a single validation state that corresponds
to the specification's initial state:
\[\{(\_\mapsto\#0,\{\#0\equiv0\})\}\]
Here the initial validation state says ``all addresses are mapped to variable
$\#0$, and the value of variable $\#0$ is constrained to be zero''.  This
reflects the initial server state that maps all addresses to zero value.

The validator's loop body is derived by dualzing the server model:
\begin{enumerate}
  \item When the server performs a write operation $!dst\coloneqq exp$, the
    validator creates a fresh variable $x$ to represent the new value stored in
    address $!dst$, and adds a constraint that says $x$'s value is equal to that
    of $exp$.
  \item When the server makes a nondeterministic branch $\If e_1\le e_2\Then
    p_1\Else p_2$, consider both cases: (a) If $p_1$ was taken, then the
    validator should add a constraint $e_1\le e_2$; or (b) If $p_2$ was taken,
    then the validator should add constraint $e_2<e_1$.
  \item Before executing the program, the server writes the internal
    choice $c$ to address $!1$.  Accordingly, the validator creates a fresh
    variable to represent the new value stored in address $!1$, without adding
    any constraint.
  \item After executing the program, the server sends back the value stored in
    $!0$ as response.  Accordingly, the validator adds a constraint that says
    the variable representing address $!0$ is equal to the observed response.
  \item If the constraints of a validation state is unsatisfiable, 
\end{enumerate}

\begin{figure}
\[\begin{array}{l@{\;}r@{\;}l}
\validatorOf(p)&\triangleq&\existT{V}{\Set((\Nat\to\Var)\times\Set\constraint)}{\\
  &&(\vstep_p,\{(\_\mapsto\#0,\{\#0\equiv0\})\})}\\
\vstep_p(q,a,v)&\triangleq&\letin{v'}{\vstep'_p(q,a,v)}\\
&&\If v'\Is\varnothing\Then\None\Else\Some v'\\
\vstep'_p(q,a,v)&\triangleq&(vs_0,cs_0)\gets v;\\
&&\letin{x_c}{\Fresh vs_0}\\
&&\letin{vs_1}{\update{vs_0}{1}{x_c}}\\
&&\letin{x_q}{\Fresh vs_1}\\
&&\letin{v_2}{(\update{vs_1}{0}{x_q},cs_0\cup\{\#x_q\equiv q\})}\\
&&(vs_3,cs_3)\gets\Eval(p,v_2);\\
&&\letin{cs_4}{cs_3\cup\{\#(vs_3!0)\equiv a\}}\\
&&\If\solvable cs_4\Then\{(vs_4,cs_4)\}\Else\varnothing\\
\Eval(p,(vs,cs))&\triangleq&\begin{cases}
  \{(vs,cs)\}&p\Is\Return\\
  \left(\begin{array}{@{}l}
    \letin{x_e}{\Fresh vs}\\
    \letin{v'}{(\update{vs}{d}{x_e},cs\cup\{\#x_e\equiv e^{vs}\})}\\
    \Eval(p',v')
  \end{array}\right)&p\Is !d\coloneqq e;p'\\
  \left(\begin{array}{@{}l}
    \letin{v_1}{(vs,cs\cup\{{e_1}^{vs}\le{e_2}^{vs}\})}\\
    \letin{v_2}{(vs,cs\cup\{{e_2}^{vs}<{e_1}^{vs}\})}\\
    \Eval(p_1,v_1)\cup\Eval(p_2,v_2)
  \end{array}\right)&\begin{array}{@{}l}p\Is\\
    \If e_1\le e_2\\
    \tthen p_1\Else p_2\end{array}
\end{cases}\\
e^{vs}&\triangleq&\begin{cases}
  n&e\Is n:\Nat\\
  \#(vs!src)&e\Is!src\\
  {e_1}^{vs}\;op\;{e_2}^{vs}&e\Is e_1\;op\;e_2
\end{cases}
\end{array}\]
\caption[Dualizing server model into validator]{Dualizing server model into
  validator.  }
\label{fig:dualize}
\end{figure}



This
requires the validator to maintain a set of validation states , one for each
possible execution path of the server model.  The validator should reject the
trace if all of its validation states are rejecting, indicating that no branch
in the server model can explain the trace:


When the constraints of a validation state becomes unsatisfiable, it indicates
that the server model cannot explain the observation.  This is because either
(i) the observation is invalid {\it i.e.} not producible by the server model, or
(ii) the observation is valid, but was produced by a different execution path of
the server model.


A validation state is rejecting if its constraints are not satisfiable, {\it
  i.e.} the observed response cannot unify with its symbolic representation
defined in the server model.


This mechanism is formalized in \autoref{fig:dualize}.  Here notation ``$x\gets
v;f(x)$'' is a monadic bind for sets: Let $f$ map each element $(vs,cs)$ in $v$
to a set of validation states
$(f(vs,cs):\Set((\Nat\to\Nat)\times\Set\constraint))$.  The return value of
$\vstep_p'$ is the union of all result sets.

The validator assumes a constraint solver that can determine whether a set of
constraints is satisfiable, {\it i.e.} there exists an assignment of all
variables that satisfy all the constraints:
\begin{gather*}
  \forall cs,\solvable cs\iff\exists (asgn:\Nat\to\Nat),\satisfy{asgn}cs\\
  \begin{array}{r@{\;}l}
    \satisfy{asgn}cs\triangleq&\forall(e_1\;cmp\;e_2)\in cs, {e_1}^{asgn}\;cmp\;{e_2}^{asgn}\\
    e^{asgn}\triangleq&\begin{cases}
      n&e\Is n:\Nat\\
      asgn!x&e\Is \#x\\
      {e_1}^{asgn}\;op\;{e_2}^{asgn}&e\Is e_1\;op\;e_2
    \end{cases}
  \end{array}
\end{gather*}

For example, the initial validation state can be satisfied by any assignment
whose value at $\#0$ is equal to zero.  The $\vstep_p'$ function adds constraints
to each validation state, until its constraints become unsolvable, and gets
dropped from the result.

If the constraints in all validation states are unsolvable, then $\vstep_p'$
returns an empty result set $\varnothing$, which leads to rejection of the trace
($\vstep_p$ returning $\None$).
