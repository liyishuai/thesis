As discussed in \autoref{sec:internal-external-nondeterminism}, nondeterminism
makes validators difficult to write.  To address this challenge, I construct
validators {\em automatically} from the specification.  The key idea is to
encode the specification with a programming language, and {\em dualize} the
specification program into the validator.

This chapter demonstrates the dualization technique with a programming language
in the QAC family.  \autoref{sec:encode-spec} introduces the $\Prog$ language
for encoding specifications.  Specification written in $\Prog$ are dualized into
validators in \autoref{sec:dualize-prog}, with correctness proven in
\autoref{sec:proof}.

\section{Encoding Specification Programs}
\label{sec:encode-spec}
Constructing the validator automatically requires analyzing the computations of
the specification program.  The QAC language family in \autoref{sec:qac} only
provides a state monad interface for server models, which is insufficient for
performing structural analysis.  This section introduces a programming language
for encoding specifications.

For readability, I demonstrate the dualization technique on a subset of QAC
server models called integer machine model, featuring random-access memory (RAM)
and arithmetic operations of integers.  To test real-world systems like HTTP,
I'll employ a more complex specification language in \autoref{chap:itree}.

\begin{definition}[Integer machine model]
  The server state of an integer machine model is a key-value mapping, where the
  keys are natural numbers, and the values are integers.  The initial server
  state maps all keys to zero:
  \begin{align*}
    &s_0:\Nat\to\Int\\
    &s_0=(\_\mapsto0)\\
    &\textit{i.e. }\forall (k:\Nat), s_0!k=0
  \end{align*}
  Here syntax ``$s!k$'' represents the integer value of key $(k:\Nat)$ mapped by
  $(s:\Nat\to\Int)$.

  The server's query, response, and choices ($Q$, $A$, $C$) are of type integer.
  At the beginning of each server loop, the query is written to address $!0$,
  and the internal choice is written to address $!1$.  The server then performs
  some computation that manipulates the server state, and then sends back the
  value stored in address $!0$ as the response:
\end{definition}


\[\begin{array}{lrll}
\Prog&\triangleq&\Return&\text{end computation and send response}\\
&\mid&!dst\coloneqq\Sexp;\Prog&\text{write to address }dst\in\Nat\\\null
&\mid&\If\Sexp\le\Sexp\Then\Prog\Else\Prog&\text{conditional branch}\\
\Sexp&\triangleq&\Int&\text{constant integer}\\
&\mid&!src&\text{read from address }src\in\Nat\\
&\mid&\Sexp\oop\Sexp&op\in\{+,-,\times,\div\}
\end{array}
\]

\begin{definition}[Server and validator of a program]
  A program $p\in\Lang$ is a representation of computation that can be
  ``instantiated'' into a server model:
  \[\serverOf:\Lang\to\Server\]
  
  A program can also be ``interpreted'' into other computations, including
  validators:
  \[\validatorOf:\Lang\to\Validator\]
\end{definition}

Servers specified in this $\Prog$ language are defined as follows:
\begin{enumerate}
\item The server's query, response, and choices ($Q$, $A$, $C$) are all
  natural numbers.
  \[\serverOf(p)\triangleq\existT{S}{\Nat\to\Int}{(\sstep_p,(\_\mapsto0))}\]
\item At the beginning of each server loop, the query is written to address
  $!0$, and the internal choice is written to address $!1$.
\item After writing the query and response, the server $\Exec$utes the $\Prog$
  model, which manipulates the key-value store.
\item When the $\Prog$ model $\Return$s, the server sends back the value stored
  in address $!0$ as the response.
\end{enumerate}
Let $p\in\Prog$ be the model program, then the server's loop body $\sstep_p$ is
defined as:
\[\begin{array}{lr@{\,}l}
\sstep_p(q,c,s_0)&\triangleq&\letin{s_1}{\update{s_0}{1}{c}}\\
&&\letin{s_2}{\update{s_1}{0}{q}}\\
&&\letin{s_3}{\Exec(p,s_2)}\\
&&(s_3!0,s_3)\\
\Exec(p,s)&\triangleq&
\begin{cases}
  s&p\Is\Return\\
  \Exec(p',\update{s}{dst}{e^s})&p\Is !dst\coloneqq e;p'\\
  \Exec(\If {e_1}^s\le{e_2}^s\Then p_1\Else p_2,s)&p\Is\If e_1\le e_2\Then p_1\Else p_2
\end{cases}\\
e^s&\triangleq&
\begin{cases}
  z&e\Is z:\Int\\
  s!src&e\Is !src\\
  {e_1}^s\oop{e_2}^s&e\Is e_1\oop e_2
\end{cases}
\end{array}\]
Here ``$e^s$'' is pronounced ``evaluating server expression $(e:\Sexp)$ with
state $(s:\Nat\to\Int)$''.  It substitutes all occurences of ``$!src$'' with the
value stored at address $src$ of mapping $s$, written as ``$s!src$''.
``$s[k\mapsto v]$'' is pronounced ``updating mapping $s$ at address $k$ to value
$v$''.  It produces a new state where $k$ is mapped to $v$, while other
addresses remain unchanged from $s$:
\[s[k\mapsto v]!k'\triangleq\begin{cases}v&k'=k\\
s!k'&k'\neq k\end{cases}\]

To specify protocols with this $\Prog$ language, the model program should read
the query from address $!0$, and parameterize the space of nondeterministic
behavior over the internal choice in address $!1$.  When the model program
returns, it should have stored the computed response in address $!0$.  Addresses
greater than $!1$ are only writable by the specification, and can be used for
storing the server state.

For example, the CMP-RST specification in \autoref{sec:qac} can be written in
$\Prog$ as:
\[\begin{array}{ll}
\If !0\le!2\Then !0\coloneqq0;\Return&(1)\\
\eelse!0\coloneqq1;!2\coloneqq!1;\Return&(2)
\end{array}\]
When the query is less than or equal to the value stored in $!2$ (case 1), the
server writes response $0$ to address $!0$, and leave address $!2$ untouched.
For queries greater than the value in $!2$ (case 2), the server writes $1$ as
response, and updates address $!2$ with the internal choice stored in $!1$.

This $\Prog$ language features arithmetic operations, conditional branches,
memory access, and internal nondeterminism.  It also exhibits a tree structure
that allows inductive reasoning.  The rest of this section derives validators
from $\Prog$ models, and prove the correctness of such derived validators.

\section{Dualize model program into validator}
\label{sec:dualize-prog}
The validator of a model $p\in\Prog$ needs to determine whether the trace is
producible by $p$.  More specifically, whether the responses in the trace can be
{\em explained} by $p$'s return value stored at address $!0$.

The idea is similar to \ilc{tester} in \autoref{sec:interactive-testing}, which
\ilc{validate}s the trace by executing the \ilc{serverSpec}, and comparing the
expected response against the tester's observation.

However, when the specification is nondeterministic, the expectation of response
$A$ is parameterized over the internal choice $C$.  Therefore, the validator
should determine whether there exists such $C$ that led the specification to
produce the observed $A$.

This reduces the trace validation problem to constraint solving.  Upon observing
a response, the validator adds a constraint that the observation can be
explained by running the specification with certain value of choices.

More specifically, the validator executes the $\Prog$ model and represents
internal choices with {\em symbolic variables}.  These variables are carried
along the program execution, so the expected responses are computed as {\em
  symbolic expressions} that might depend on those variables.  The validator
then constraints that the symbolic response is equal to the concrete
observation.

To achieve this goal, the validator needs to store the symbolic expression for
each address of the server model.  It also needs to remember all the constraints
added upon observation.  I store these information as ``validation states'':
\[(\Nat\to\Vexp)\times\Set\constraint\]
Here the $\constraint$s are relations between validator expressions ($\Vexp$s)
that may depend on symbolic $\Var$iables:
\[\begin{array}{lrl@{\qquad}l}
\constraint&\triangleq&\Vexp\ccmp\Vexp&cmp\in\{<,\le,\equiv\}\\
\Vexp&\triangleq&\Int&\text{constant integer}\\
&\mid&\#x&\text{variable }x\in\Var\\
&\mid&\Vexp\oop\Vexp&op\in\{+,-,\times,\div\}\\
\end{array}\]

In practice, I use an equivalent definition for the validator state:
\[(\Nat\to\Var)\times\Set\constraint\]
The key-expression mapping $(k\mapsto e)$ above can be simulated with the
key-variable $(k\mapsto x)$ mapping here, by adding $(\#x\equiv e)$ to the set
of constraints.  I alter the type interface for convenience of developing the
validator.

Notice that the internal choices might affect branch conditions, so the
validator doesn't know which branch in the specification was taken.  Therefore,
it should maintain multiple validation states, one for each possible execution
path of the specification:
\[\Set((\Nat\to\Var)\times\Set\constraint)\]

The initial state of the validator is a single validation state that corresponds
to the specification's initial state:
\[\{(\_\mapsto\#0,\{\#0\equiv0\})\}\]
Here the initial validation state says ``all addresses are mapped to variable
$\#0$, and the value of variable $\#0$ is constrained to be zero''.  This
reflects the initial server state that maps all addresses to zero value.

The validator's loop body is derived by dualzing the server model:

\begin{figure}[h]
\[\begin{array}{l@{\;}r@{\;}l}
\validatorOf(p)&\triangleq&\existT{V}{\Set((\Nat\to\Var)\times\Set\constraint)}{\\
  &&(\vstep_p,\{(\_\mapsto\#0,\{\#0\equiv0\})\})}\\
\vstep_p(q,a,v)&\triangleq&\letin{v'}{v_0\gets v;\vstep'_p(q,a,v_0)}\\
&&\If v'\Is\varnothing\Then\None\Else\Some v'\hfill(\ref{rule:reject})\\
\vstep'_p(q,a,v_0)&\triangleq&\letin{v_1}{\Havoc(1,v_0)}\\
&&\letin{v_2}{\Write(0,q,v_1)}\\
&&(vs_3,cs_3)\gets\Exec(p,v_2);\\
&&\letin{cs_4}{cs_3\cup\{\#(vs_3!0)\equiv a\}}\hfill(\ref{rule:return})\\
&&\If\solvable cs_4\Then\{(vs_3,cs_4)\}\Else\varnothing\hfill(\ref{rule:unsat})\\
\Exec(p,(vs,cs))&\triangleq&\begin{cases}
  \{(vs,cs)\}&p\Is\Return\\
  \Exec(p',\Write(d,e,(vs,cs)))&p\Is !d\coloneqq e;p'\\
  \left(\begin{array}{@{}l}
    \letin{v_1}{(vs,cs\cup\{{e_1}^{vs}\le{e_2}^{vs}\})}\\
    \letin{v_2}{(vs,cs\cup\{{e_2}^{vs}<{e_1}^{vs}\})}\\
    \Exec(p_1,v_1)\cup\Exec(p_2,v_2)\hfill(\ref{rule:branch})
  \end{array}\right)&\begin{array}{@{}l}p\Is\\
    \If e_1\le e_2\\
    \tthen p_1\Else p_2\end{array}
\end{cases}\\
\Write(d,e,(vs,cs))&\triangleq&\letin{x_e}{\Fresh (vs,cs)}\hfill(\ref{rule:write})\\
&&(\update{vs}{d}{x_e},cs\cup\{\#x_e\equiv e^{vs}\})\\
\Havoc(d,(vs,cs))&\triangleq&\letin{x_c}{\Fresh (vs,cs)}(\update{vs}{d}{x_c},cs)\hfill(\ref{rule:choice})\\
e^{vs}&\triangleq&\begin{cases}
  n&e\Is n:\Nat\\
  \#(vs!src)&e\Is!src\\
  {e_1}^{vs}\oop{e_2}^{vs}&e\Is e_1\oop e_2
\end{cases}
\end{array}\]
\caption[Dualizing server model into validator]{Dualizing server model into
  validator, with derivation rules annotated.}
\label{fig:dualize}
\end{figure}

\begin{enumerate}
\item \label{rule:write} When the server performs a write operation
  $!dst\coloneqq exp$, the validator creates a fresh variable $x$ to represent
  the new value stored in address $!dst$, and adds a constraint that says $x$'s
  value is equal to that of $exp$.
\item \label{rule:branch} When the server makes a nondeterministic branch $\If
  e_1\le e_2\Then p_1\Else p_2$, consider both cases: (a) If $p_1$ was taken,
  then the validator should add a constraint $e_1\le e_2$; or (b) If $p_2$ was
  taken, then the validator should add constraint $e_2<e_1$.
\item \label{rule:choice} Before executing the program, the server writes the internal
    choice $c$ to address $!1$.  Accordingly, the validator creates a fresh
    variable to represent the new value stored in address $!1$, without adding
    any constraint.
\item \label{rule:return} After executing the program, the server sends back the
  value stored in $!0$ as response.  Accordingly, the validator adds a
  constraint that says the variable representing address $!0$ is equal to the
  observed response.
\item \label{rule:unsat} When the constraints of a validation state becomes
  unsatisfiable, it indicates that the server model cannot explain the
  observation.  This is because either (i) the observation is invalid {\it i.e.}
  not producible by the server model, or (ii) the observation is valid, but was
  produced by a different execution path of the server model.
\item \label{rule:reject} The validator accepts the trace if it can be produced
  by any execution path of the server model.  Since each execution path
  corresponds to a validation state, the validator only needs to remove the
  unsatisfiable state from the set of states.  If the set of validation states
  becomes empty, it indicates that the observation cannot be explained by any
  execution path of the specification, so the validator should reject the trace.
\end{enumerate}

This mechanism is formalized in \autoref{fig:dualize}.  Here notation
``$v_0\gets v;\vstep'_p(q,a,v_0)$'' is a monadic bind for sets: Let $\vstep'_p$
map each element $v_0$ in $v$ to a set of validation states
$(\vstep'_p(q,a,v_0):\Set((\Nat\to\Var)\times\Set\constraint))$, and return the
union of all result sets as $v'$.

The validator assumes a constraint solver that can determine whether a set of
constraints is satisfiable, {\it i.e.} whether there exists an {\em assignment}
of variables $(\Var\to\Int)$ that satisfy all the constraints:
\begin{gather*}
  \forall cs,\solvable cs\iff\exists (asgn:\Var\to\Int),\satisfy{asgn}cs\\
  \begin{array}{r@{\;}l}
    \satisfy{asgn}cs\triangleq&\forall(e_1\ccmp e_2)\in cs, {e_1}^{asgn}\ccmp{e_2}^{asgn}\\
    e^{asgn}\triangleq&\begin{cases}
      z&e\Is z:\Int\\
      asgn!x&e\Is \#x\\
      {e_1}^{asgn}\oop{e_2}^{asgn}&e\Is e_1\oop e_2
    \end{cases}
  \end{array}
\end{gather*}
Here ``$e^{asgn}$'' is pronounced ``evaluating validator expression $(e:\Vexp)$
with assignment $(asgn:\Var\to\Int)$''.  It substitutes all occurences of
``$\#x$'' with their assigned value $(asgn!x)$.

When the $\Prog$ model writes to memories or makes conditional branches, the
operands are represented as specification expressions ($\Sexp$) that refer to
server addresses.  To construct the constraints over symbolic variables, the
validator translates the expressions $(e:\Sexp)$ into validator expressions
$(e^{vs}:\Vexp)$ by {\em symbolizing} it with the validation state
$(vs:\Nat\to\Var)$, which substitutes all addresses $(!src)$ with their
corresponding variable $\#(vs!src)$.

\begin{figure}[h]
\begin{align*}
&\validatorOf(\texttt{CMP-RST})\triangleq\existT{V}{\Set((\Nat\to\Var)\times\Set\constraint)}\\
  &\begin{array}{rll}
     (&\lam{(q,a,v)}{&\llet v'=\begin{array}[t]{@{}l@{}l@{}ll}
       \multicolumn{3}{@{}l}{(vs_0,cs_0)\gets v;}\\
       \letin{vs_1&}{\update{vs_0}{1}{\Fresh (vs_0,cs_0)}&}&\text{(1)}\\
       \letin{x_q&}{\Fresh (vs_1,cs_0)&}\\
       \letin{vs_2&}{\update{vs_1}{0}{x_q}&}\\
       \letin{cs_2&}{cs_0\cup\{\#x_q\equiv q\}&}\\
       \letin{cs_{3a0}&}{cs_2\cup\{\#(vs_2!0)\le\#(vs_2!2))\}&}&\text{(2a)}\\
       \letin{x_{3a1}&}{\Fresh (vs_2,cs_{3a0})&}\\
       \letin{vs_{3a1}&}{\update{vs_2}{0}{x_{3a1}}&}\\
       \letin{cs_{3a1}&}{cs_{3a0}\cup\{\#x_{3a1}\equiv0\}&}\\
       \letin{cs_{3b0}&}{cs_2\cup\{\#(vs_2!2)<\#(vs_2!0)\}&}&\text{(2b)}\\
       \letin{x_{3b1}&}{\Fresh (vs_2,cs_{3b0})&}\\
       \letin{vs_{3b1}&}{\update{vs_2}{0}{x_{3b1}}&}\\
       \letin{cs_{3b1}&}{cs_{3b0}\cup\{\#x_{3b1}\equiv1\}&}\\
       \letin{x_{3b2}&}{\Fresh (vs_{3b1},cs_{3b1})&}\\
       \letin{vs_{3b2}&}{\update{vs_{3b1}}{2}{x_{3b2}}&}\\
       \letin{cs_{3b2}&}{cs_{3b1}\cup\{\#x_{3b2}\equiv\#(vs_{3b2}!1)\}&}\\
       \multicolumn{3}{@{}l}{((vs_4,cs_4)\gets\{(vs_{3a1},cs_{3a1}),(vs_{3b2},cs_{3b2})\};}&\text{(3)}\\
       \letin{cs_5&}{cs_4\cup\{\#(vs_4!0)\equiv a\}&}\\
       \multicolumn{3}{@{}l}{\If\solvable cs_5\Then\{(vs_4,cs_5)\}\Else\varnothing}\\
       \end{array}\\
       &&\iin\\
       &&\If v'\Is\varnothing\Then\None\Else\Some v'
     }\\
     ,&\multicolumn{2}{l}{\{(\_\mapsto\#0,\{\#0\equiv0\})\}})
   \end{array}
\end{align*}
\caption[Validator for protocol CMP-RST]{Validator for CMP-RST, derived from
  $\Prog$ model.  This program consists of three parts: (1) symbolizing the
  query and internal choice before executing the model, (2) considering both
  branches in the model program, propagating a validation state for each branch,
  (3) filtering the validation states by constraint satisfiability, removing
  invalid states.}
\label{fig:derived-validator}
\end{figure}

For example, by dualizing the $\Prog$ model for CMP-RST in
\autoref{sec:proglang}, we get a validator as shown in
\autoref{fig:derived-validator}.  Such derived validators are proven sound and
complete in the following section.

\section{Correctness Proof}
\label{sec:proof}
\input{proof}
