So far we have defined the QAC language family, where specifications and
validators are represented as state monads.  This section will show how to
derive validators from the specification.

\subsection{Encoding specifications and validators}
\label{sec:proglang}
To write an algorithm from the specification to the validator, we need to
analyze the computations defined by the specification's model program.  The QAC
language family only provides a state monad interface, which is not destructable
by itself.  We need to introduce a programming language to represent the
specification, and derive validators by interpreting programs written in that
language.

\begin{definition}[Server and validator of a program]
  A program $p\in\Prog$ is a representation of computation that can be
  ``instantiated'' into a server model:
  \[\serverOf:\Prog\to\Server\]
  
  A program can also be ``interpreted'' into other computations, including
  validators:
  \[\validatorOf:\Prog\to\Validator\]
\end{definition}
To encode specifications for protocols like CMP-RST, we introduce a simple
$\Prog$ language, which supports arithmetic operations and memory access:
\[\begin{array}{lrll}
\Prog&\triangleq&\Return&\text{end computation and send response}\\
&\mid&!dst\coloneqq\Sexp;\Prog&\text{write to address }dst\in\Nat\\\null
&\mid&\If\Sexp\le\Sexp\Then\Prog\Else\Prog&\text{conditional branch}\\
\Sexp&\triangleq&\Int&\text{constant integer}\\
&\mid&!src&\text{read from address }src\in\Nat\\
&\mid&\Sexp\;op\;\Sexp&op\in\{+,-,\times,\div\}
\end{array}
\]

Servers specified in this $\Prog$ language are defined as follows:
\begin{enumerate}
\item The server state is a key-value mapping, where the keys are natural
  numbers, and the values are integers.
\item The initial server state maps all keys to zero:
  \[\serverOf(p)\triangleq\existT{S}{\Nat\to\Int}{(\sstep_p,(\_\mapsto0))}\]
\item The server's query, response, and choices ($Q$, $A$, $C$) are all
  natural numbers.
\item At the beginning of each server loop, the query is written to address
  $!0$, and the internal choice is written to address $!1$.
\item After writing the query and response, the server $\Exec$utes the $\Prog$
  model, which manipulates the key-value store.
\item When the $\Prog$ model $\Return$s, the server sends back the value stored
  in address $!0$ as the response.
\end{enumerate}
Let $p\in\Prog$ be the model program, then the server's loop body $\sstep_p$ is
defined as:
\[\begin{array}{lrl}
\sstep_p(q,c,s_0)&\triangleq&\letin{s_1}{\update{s_0}{1}{c}}\\
&&\letin{s_2}{\update{s_1}{0}{q}}\\
&&\letin{s_3}{\Exec(p,s_2)}\\
&&(s_3!0,s_3)\\
\Exec(p,s)&\triangleq&
\begin{cases}
  s&p\Is\Return\\
  \Exec(p',\update{s}{dst}{e^s})&p\Is !dst\coloneqq e;p'\\
  \Exec(\If {e_1}^s\le{e_2}^s\Then p_1\Else p_2,s)&p\Is\If e_1\le e_2\Then p_1\Else p_2
\end{cases}\\
e^s&\triangleq&
\begin{cases}
  z&e\Is z:\Int\\
  s!src&e\Is !src\\
  {e_1}^s\;op\;{e_2}^s&e\Is e_1\;op\;e_2
\end{cases}
\end{array}\]
Here ``$e^s$'' is pronounced ``evaluating expression $e$ with state $s$''.  It
substitutes all occurences of ``$!src$'' to the value stored at address $src$ of
mapping $s$, written as ``$s!src$''.  ``$s[k\mapsto v]$'' is pronounced
``updating mapping $s$ at address $k$ to value $v$''.  It produces a new state
where $k$ is mapped to $v$, while other addresses remain unchanged from $s$:
\[s[k\mapsto v]!k'\triangleq\begin{cases}v&k'=k\\
s!k'&k'\neq k\end{cases}\]

To specify protocols with this $\Prog$ language, the model program should read
the query from address $!0$, and parameterize the space of nondeterministic
behavior over the internal choice in address $!1$.  When the model program
returns, it should have stored the computed response in address $!0$.  Addresses
greater than $!1$ are only writable by the specification, and can be used for
storing the server state.

For example, the CMP-RST specification in \autoref{sec:qac} can be written in
$\Prog$ as:
\[\begin{array}{ll}
\If !0\le!2\Then !0\coloneqq0;\Return&(1)\\
\eelse!0\coloneqq1;!2\coloneqq!1;\Return&(2)
\end{array}\]
When the query is less than or equal to the value stored in $!2$ (case 1), the
server writes response $0$ to address $!0$, and leave address $!2$ untouched.
For queries greater than the value in $!2$ (case 2), the server writes $1$ as
response, and updates address $!2$ with the internal choice stored in $!1$.

This $\Prog$ language features arithmetic operations, conditional branches,
memory access, and internal nondeterminism.  It also exhibits a tree structure
that allows inductive reasoning.  The rest of this section derives validators
from $\Prog$ models, and prove the correctness of such derived validators.

\subsection{Dualize model program into validator}
The validator of a model $p\in\Prog$ needs to determine whether the trace is
producible by $p$.  More specifically, whether the responses in the trace can be
{\em explained} by $p$'s return value stored at address $!0$.

The idea is similar to \ilc{tester} in \autoref{sec:interactive-testing}, which
\ilc{validate}s the trace by executing the \ilc{serverSpec}, and comparing the
expected response against the tester's observation.

However, when the specification is nondeterministic, the expectation of response
$A$ is parameterized over the internal choice $C$.  Therefore, the validator
should determine whether there exists such $C$ that led the specification to
produce the observed $A$.

This reduces the trace validation problem to constraint solving.  Upon observing
a response, the validator adds a constraint that the observation can be
explained by running the specification with certain value of choices.

More specifically, the validator executes the $\Prog$ model and represents
internal choices with {\em symbolic variables}.  These variables are carried
along the program execution, so the expected responses are computed as {\em
  symbolic expressions} that might depend on those variables.  The validator
then constraints that the symbolic response is equal to the concrete
observation.

To achieve this goal, the validator needs to store the symbolic expression for
each address of the server model.  It also needs to remember all the constraints
added upon observation.  We store these information as ``validation states'':
\[(\Nat\to\Vexp)\times\Set\constraint\]
Here the $\constraint$s are relations between validator expressions ($\Vexp$s)
that may depend on symbolic $\Var$iables:
\[\begin{array}{lrl@{\qquad}l}
\constraint&\triangleq&\Vexp\;cmp\;\Vexp&cmp\in\{<,\le,\equiv\}\\
\Vexp&\triangleq&\Int&\text{constant integer}\\
&\mid&\#x&\text{variable }x\in\Var\\
&\mid&\Vexp\;op\;\Vexp&op\in\{+,-,\times,\div\}\\
\end{array}\]

In practice, we use an equivalent definition for the validator state:
\[(\Nat\to\Var)\times\Set\constraint\]
The key-expression mapping $(k\mapsto e)$ above can be simulated with the
key-variable $(k\mapsto x)$ mapping here, by adding $(\#x\equiv e)$ to the set
of constraints.  We alter the type interface for convenience of developing the
validator, which will be later explained in more details.

Notice that the internal choices might affect branch conditions, so the
validator doesn't know which branch in the specification was taken.  Therefore,
it should maintain multiple validation states, one for each possible execution
path of the specification:
\[\Set((\Nat\to\Var)\times\Set\constraint)\]

The initial state of the validator is a single validation state that corresponds
to the specification's initial state:
\[\{(\_\mapsto\#0,\{\#0\equiv0\})\}\]
Here the initial validation state says ``all addresses are mapped to variable
$\#0$, and the value of variable $\#0$ is constrained to be zero''.  This
reflects the initial server state that maps all addresses to zero value.

The validator's loop body is derived by dualzing the server model:
\begin{enumerate}
\item \label{rule:write} When the server performs a write operation
  $!dst\coloneqq exp$, the validator creates a fresh variable $x$ to represent
  the new value stored in address $!dst$, and adds a constraint that says $x$'s
  value is equal to that of $exp$.
\item \label{rule:branch} When the server makes a nondeterministic branch $\If
  e_1\le e_2\Then p_1\Else p_2$, consider both cases: (a) If $p_1$ was taken,
  then the validator should add a constraint $e_1\le e_2$; or (b) If $p_2$ was
  taken, then the validator should add constraint $e_2<e_1$.
\item \label{rule:choice} Before executing the program, the server writes the internal
    choice $c$ to address $!1$.  Accordingly, the validator creates a fresh
    variable to represent the new value stored in address $!1$, without adding
    any constraint.
\item \label{rule:return} After executing the program, the server sends back the
  value stored in $!0$ as response.  Accordingly, the validator adds a
  constraint that says the variable representing address $!0$ is equal to the
  observed response.
\item \label{rule:unsat} When the constraints of a validation state becomes
  unsatisfiable, it indicates that the server model cannot explain the
  observation.  This is because either (i) the observation is invalid {\it i.e.}
  not producible by the server model, or (ii) the observation is valid, but was
  produced by a different execution path of the server model.
\item \label{rule:reject} The validator accepts the trace if it can be produced
  by any execution path of the server model.  Since each execution path
  corresponds to a validation state, the validator only needs to remove the
  unsatisfiable state from the set of states.  If the set of validation states
  becomes empty, it indicates that the observation cannot be explained by any
  execution path of the specification, so the validator should reject the trace.
\end{enumerate}

\begin{figure}
\[\begin{array}{l@{\;}r@{\;}l}
\validatorOf(p)&\triangleq&\existT{V}{\Set((\Nat\to\Var)\times\Set\constraint)}{\\
  &&(\vstep_p,\{(\_\mapsto\#0,\{\#0\equiv0\})\})}\\
\vstep_p(q,a,v)&\triangleq&\letin{v'}{\vstep'_p(q,a,v)}\\
&&\If v'\Is\varnothing\Then\None\Else\Some v'\hfill(\ref{rule:reject})\\
\vstep'_p(q,a,v)&\triangleq&(vs_0,cs_0)\gets v;\\
&&\letin{x_c}{\Fresh vs_0}\\
&&\letin{vs_1}{\update{vs_0}{1}{x_c}}\hfill(\ref{rule:choice})\\
&&\letin{x_q}{\Fresh vs_1}\\
&&\letin{v_2}{(\update{vs_1}{0}{x_q},cs_0\cup\{\#x_q\equiv q\})}\hfill(\ref{rule:write})\\
&&(vs_3,cs_3)\gets\Exec(p,v_2);\\
&&\letin{cs_4}{cs_3\cup\{\#(vs_3!0)\equiv a\}}\hfill(\ref{rule:return})\\
&&\If\solvable cs_4\Then\{(vs_3,cs_4)\}\Else\varnothing\hfill(\ref{rule:unsat})\\
\Exec(p,(vs,cs))&\triangleq&\begin{cases}
  \{(vs,cs)\}&p\Is\Return\\
  \left(\begin{array}{@{}l}
    \letin{x_e}{\Fresh vs}\\
    \letin{v'}{(\update{vs}{d}{x_e},cs\cup\{\#x_e\equiv e^{vs}\})}\\
    \Exec(p',v')\hfill(\ref{rule:write})
  \end{array}\right)&p\Is !d\coloneqq e;p'\\
  \left(\begin{array}{@{}l}
    \letin{v_1}{(vs,cs\cup\{{e_1}^{vs}\le{e_2}^{vs}\})}\\
    \letin{v_2}{(vs,cs\cup\{{e_2}^{vs}<{e_1}^{vs}\})}\\
    \Exec(p_1,v_1)\cup\Exec(p_2,v_2)\hfill(\ref{rule:branch})
  \end{array}\right)&\begin{array}{@{}l}p\Is\\
    \If e_1\le e_2\\
    \tthen p_1\Else p_2\end{array}
\end{cases}\\
e^{vs}&\triangleq&\begin{cases}
  n&e\Is n:\Nat\\
  \#(vs!src)&e\Is!src\\
  {e_1}^{vs}\;op\;{e_2}^{vs}&e\Is e_1\;op\;e_2
\end{cases}
\end{array}\]
\caption[Dualizing server model into validator]{Dualizing server model into
  validator, with derivation rules annotated.}
\label{fig:dualize}
\end{figure}

This mechanism is formalized in \autoref{fig:dualize}.  Here notation ``$x\gets
v;f(x)$'' is a monadic bind for sets: Let $f$ map each element $(vs,cs)$ in $v$
to a set of validation states
$(f(vs,cs):\Set((\Nat\to\Nat)\times\Set\constraint))$.  The return value of
$\vstep_p'$ is the union of all result sets.

The validator assumes a constraint solver that can determine whether a set of
constraints is satisfiable, {\it i.e.} there exists an assignment of all
variables that satisfy all the constraints:
\begin{gather*}
  \forall cs,\solvable cs\iff\exists (asgn:\Nat\to\Nat),\satisfy{asgn}cs\\
  \begin{array}{r@{\;}l}
    \satisfy{asgn}cs\triangleq&\forall(e_1\;cmp\;e_2)\in cs, {e_1}^{asgn}\;cmp\;{e_2}^{asgn}\\
    e^{asgn}\triangleq&\begin{cases}
      n&e\Is n:\Nat\\
      asgn!x&e\Is \#x\\
      {e_1}^{asgn}\;op\;{e_2}^{asgn}&e\Is e_1\;op\;e_2
    \end{cases}
  \end{array}
\end{gather*}

When the $\Prog$ model writes to memories or makes conditional branches, the
operands are represented as specification expressions ($\Sexp$) that refer to
server addresses.  To construct the constraints over symbolic variables, the
validator translates the expressions $(e:\Sexp)$ into validator expressions
$(e^{vs}:\Vexp)$ by interpreting it with the validation state
$(vs:\Nat\to\Var)$, which substitutes all addresses $(!src)$ with their
corresponding variable $\#(vs!src)$.

For example, by dualizing the $\Prog$ model for CMP-RST in
\autoref{sec:proglang}, we get a validator as shown in
\autoref{fig:derived-validator}.  Such derived validators are proven sound and
complete in the following section.
\begin{figure}
\begin{align*}
&\validatorOf(\texttt{CMP-RST})\triangleq\existT{V}{\Set((\Nat\to\Var)\times\Set\constraint)}\\
  &\begin{array}{rll}
     (&\lam{(q,a,v)}{&\llet v'=\begin{array}[t]{@{}l@{}l@{}ll}
       \multicolumn{3}{@{}l}{(vs_0,cs_0)\gets v;}\\
       \letin{vs_1&}{\update{vs_0}{1}{\Fresh vs_0}&}&\text{(1)}\\
       \letin{x_q&}{\Fresh vs_1&}\\
       \letin{vs_2&}{\update{vs_1}{0}{x_q}&}\\
       \letin{cs_2&}{cs_0\cup\{\#x_q\equiv q\}&}\\
       \letin{cs_{3a0}&}{cs_2\cup\{\#(vs_2!0)\le\#(vs_2!2))\}&}&\text{(2a)}\\
       \letin{x_{3a1}&}{\Fresh vs_2&}\\
       \letin{vs_{3a1}&}{\update{vs_2}{0}{x_{3a1}}&}\\
       \letin{cs_{3a1}&}{cs_{3a0}\cup\{\#x_{3a1}\equiv0\}&}\\
       \letin{cs_{3b0}&}{cs_2\cup\{\#(vs_2!2)<\#(vs_2!0)\}&}&\text{(2b)}\\
       \letin{x_{3b1}&}{\Fresh vs_2&}\\
       \letin{vs_{3b1}&}{\update{vs_2}{0}{x_{3b1}}&}\\
       \letin{cs_{3b1}&}{cs_{3b0}\cup\{\#x_{3b1}\equiv1\}&}\\
       \letin{x_{3b2}&}{\Fresh vs_{3b1}&}\\
       \letin{vs_{3b2}&}{\update{vs_{3b1}}{2}{x_{3b2}}&}\\
       \letin{cs_{3b2}&}{cs_{3b1}\cup\{\#x_{3b2}\equiv\#(vs_{3b2}!1)\}&}\\
       \multicolumn{3}{@{}l}{((vs_4,cs_4)\gets\{(vs_{3a1},cs_{3a1}),(vs_{3b2},cs_{3b2})\};}&\text{(3)}\\
       \letin{cs_5&}{cs_4\cup\{\#(vs_4!0)\equiv a\}&}\\
       \multicolumn{3}{@{}l}{\If\solvable cs_5\Then\{(vs_4,cs_5)\}\Else\varnothing}\\
       \end{array}\\
       &&\iin\\
       &&\If v'\Is\varnothing\Then\None\Else\Some v'
     }\\
     ,&\multicolumn{2}{l}{\{(\_\mapsto\#0,\{\#0\equiv0\})\}})
   \end{array}
\end{align*}
\caption[Validator for protocol CMP-RST]{Validator for CMP-RST, derived from
  $\Prog$ model.  This program consists of three parts: (1) symbolizing the
  query and internal choice before executing the model, (2) considering both
  branches in the model program, propagating a validation state for each branch,
  (3) filtering the validation states by constraint satisfiability, removing
  invalid states.}
\label{fig:derived-validator}
\end{figure}
