As discussed in \autoref{sec:internal-external-nondeterminism}, nondeterminism
makes validators difficult to write.  To address this challenge, I construct
validators {\em automatically} from the specification.  The key idea is to
encode the specification with a programming language, and {\em dualize} the
specification program into the validator.

This chapter demonstrates the dualization technique with a programming language
in the QAC family.  \autoref{sec:encode-spec} introduces the $\Prog$ language
for encoding specifications.  Specification written in $\Prog$ are dualized into
validators in \autoref{sec:dualize-prog}, with correctness proven in
\autoref{sec:proof}.

\section{Encoding Specifications}
\label{sec:encode-spec}
Constructing the validator automatically requires analyzing the computations of
the specification program.  The QAC language family in \autoref{sec:qac} only
provides a state monad interface for server models, which is insufficient for
performing structural analysis.  This section introduces a programming language
for encoding specifications.

For readability, I demonstrate the dualization technique on a subset of QAC
server models called integer machine model, featuring random-access memory (RAM)
and arithmetic operations.  To test real-world systems like web servers, I'll
employ a more complex specification language in \autoref{chap:itree}.

\subsection{Integer machine model}
The server state of an integer machine model is a key-value mapping that
resembles a RAM.  The addresses are natural numbers, and the data are integers.
The initial server state has zero data in all addresses:
\begin{align*}
  &s_0:\Nat\to\Int\\
  &s_0=(\_\mapsto0)\\
  &\textit{i.e. }\forall (k:\Nat), s_0!k=0
\end{align*}
Here syntax ``$s!k$'' is pronounced ``data stored in address $!k$ of memory
$s$''.

The server's query, response, and choices ($Q$, $A$, $C$) are of type integer.
At the beginning of each server loop, the internal choice is written to address
$!0$, and the query is written to address $!1$.  The server then performs some
computation $f:(\Nat\to\Int)\to(\Nat\to\Int)$ that manipulates the memory, and
then sends back the value stored in address $!1$ as the response:
\begin{align*}
  \sstep_f(q,c)(s)\quad\triangleq\quad&\letin{s_1}{\update s0c}\\
  &\letin{s_2}{\update{s_1}1q}\\
  &\letin{s_3}{f(s_2)}\\
  &(s_3!1,s_3)
\end{align*}

Each memory-manipulating computation $f$ defines an instance of the integer
machine model:
\[\existT{S}{\Nat\to\Int}{(\sstep_f,s_0)}\]

Dualizing an integer machine model requires structural analysis of its memory
manipulation.  Next I'll introduce a programming language to encode computations
$(\Nat\to\Int)\to(\Nat\to\Int)$.

\subsection{The $\Prog$ modelling language}
\paragraph{Syntax}
A program in the $\Prog$ language may read and write at any address of the
memory, perform arithmetic operations, and make conditional branches:
\[\begin{array}{lrll}
\Prog&\triangleq&\Return&\text{end computation}\\
&\mid&!dst\coloneqq\Sexp;\Prog&\text{write to address }dst\in\Nat\\\null
&\mid&\If\Sexp\le\Sexp\Then\Prog\Else\Prog&\text{conditional branch}\\
\Sexp&\triangleq&\Int&\text{constant integer}\\
&\mid&!src&\text{read from address }src\in\Nat\\
&\mid&\Sexp\oop\Sexp&op\in\{+,-,\times,\div\}
\end{array}\]

For example, the following program computes the absolute value of data stored in
$!1$, and stores it in address $!1$:
\[\begin{array}{ll}
  \If&!1\le0\\
  \tthen&!1\gets(0-!1);\;\Return\\
  \eelse&\Return
\end{array}\]

\paragraph{Semantics}
Each program $(p:\Prog)$ specifies a computation on the integer machine:
\[\begin{array}{ll}
\multicolumn{2}{l}{\Exec\;:\;\Prog\to(\Nat\to\Int)\to(\Nat\to\Int)}\\
\Exec(p)(s)&\triangleq
\begin{cases}
  s&p\Is\Return\\
  \Exec(p',\update{s}{dst}{e^s})&p\Is !dst\coloneqq e;p'\\
  \Exec(\If {e_1}^s\le{e_2}^s\Then p_1\Else p_2,s)&p\Is\If e_1\le e_2\Then p_1\Else p_2
\end{cases}\\
e^s&\triangleq
\begin{cases}
  z\hphantom{\Exec(\If {e_1}^s\le{e_2}^s\Then p_1\Else p_2,)}&e\Is z:\Int\\
  s!src&e\Is !src\\
  {e_1}^s\oop{e_2}^s&e\Is e_1\oop e_2
\end{cases}
\end{array}\]

Here ``$e^s$'' is pronounced ``evaluating server expression $(e:\Sexp)$ on
memory $(s:\Nat\to\Int)$''.  It substitutes all occurences of ``$!src$'' with
the data stored in address $!src$ of memory $s$.

Syntax ``$s[k\mapsto v]$'' is pronounced ``writing value $v$ to address $!k$ of
memory $s$''.  It produces a new memory that maps address $!k$ to $v$, while
other addresses remain unchanged from $s$:
\[s[k\mapsto v]!k'\triangleq\begin{cases}v&k'=k\\
s!k'&k'\neq k\end{cases}\]

\paragraph{From $\Prog$ to server model}
Every program in the $\Prog$ language corresponds to a server model that
performs the computations it specifies:
\begin{align*}
  &\serverOf:\Prog\to\Server\\
  &\serverOf(p)\;\triangleq\;\existT{S}{\Nat\to\Int}{(\sstep_{\Exec(p)},s_0)}
\end{align*}

For example, the CMP-RST protocol in \autoref{sec:qac-model} can be constructed
by applying $\serverOf$ to the following program:
\[\begin{array}{ll}
\If !1\le!2\Then !1\coloneqq0;\Return&(1)\\
\eelse!1\coloneqq1;!2\coloneqq!0;\Return&(2)
\end{array}\]
The constructed server stores its data $n$ in address $!2$.  When the query
stored in $!1$ is less than or equal to $!2$ (case 1), the server writes $0$ to
address $!1$ as response, and leaves the data untouched in address $!2$.  For
queries greater than $!2$ (case 2), the server writes $1$ as response, and
updates the data in $!2$ with the internal choice stored in $!0$.

Based on specifications written in the $\Prog$ language, we can now construct
the validator automatically by dualization.

\section{Dualizing Specification Programs}
\label{sec:dualize-prog}
This section presents an algorithm that constructs a validator from the
specification program:
\[\validatorOf:\Prog\to\Validator\]

For every program $p$, $\validatorOf(p)$ determines whether a trace is
producible by $\serverOf(p)$:
\begin{align*}
  &\forall (p:\Prog)(t:\List(Q\times A),\\
  &(\behaves{\validatorOf(p)}t)\;\iff\;(\behaves{\serverOf(p)}t)
\end{align*}

More specifically, given a trace of $Q\times A$ pairs, the validator determines
whether there exists a sequences of internal choices $C$ that explains how the
server produces the trace in \autoref{def:trace-validity}.

The idea is similar to the \ilc{tester} in \autoref{sec:interactive-testing},
which \ilc{validate}s the trace by executing the \ilc{serverSpec}, and comparing
the expected response against the tester's observation.

However, executing a nondeterministic specification does not produce a specific
expectation of response, but a space of responses parameterized over the
internal choices.  Therefore, upon observing a response $A$, the validator
should determine whthere there exists a choice $C$ that leads the specification
to produce this response.

This reduces the trace validation problem to constraint solving.  The validator
maintains a set of constraints that unify the responses produced by the
specification with the responses observed from the implementation.

More specifically, the validator executes the $\Prog$ model and represents
internal choices with {\em symbolic variables}.  These variables are carried
along the program execution, so the expected responses are computed as {\em
  symbolic expressions} that might depend on those variables.  The validator
then constrains that the symbolic response is equal to the concrete observation.

To achieve this goal, the validator needs to store the symbolic expression for
each address of the server model.  It also needs to remember all the constraints
added upon observation.  I store these information as ``validation states'':
\[(\Nat\to\Vexp)\times\Set\constraint\]
Here the $\constraint$s are relations between validator expressions ($\Vexp$s)
that may depend on symbolic $\Var$iables:
\[\begin{array}{lrl@{\qquad}l}
\constraint&\triangleq&\Vexp\ccmp\Vexp&cmp\in\{<,\le,\equiv\}\\
\Vexp&\triangleq&\Int&\text{constant integer}\\
&\mid&\#x&\text{variable }x\in\Var\\
&\mid&\Vexp\oop\Vexp&op\in\{+,-,\times,\div\}\\
\end{array}\]

In practice, I use an equivalent definition for the validator state:
\[(\Nat\to\Var)\times\Set\constraint\]
The key-expression mapping $(k\mapsto e)$ above can be simulated with the
key-variable $(k\mapsto x)$ mapping here, by adding $(\#x\equiv e)$ to the set
of constraints.  I alter the type interface for convenience of developing the
validator.

Notice that the internal choices might affect branch conditions, so the
validator doesn't know which branch in the specification was taken.  Therefore,
it should maintain multiple validation states, one for each possible execution
path of the specification:
\[\Set((\Nat\to\Var)\times\Set\constraint)\]

The initial state of the validator is a single validation state that corresponds
to the specification's initial state:
\[\{(\_\mapsto\#0,\{\#0\equiv0\})\}\]
Here the initial validation state says ``all addresses are mapped to variable
$\#0$, and the value of variable $\#0$ is constrained to be zero''.  This
reflects the initial server state that maps all addresses to zero value.

The validator's loop body is derived by dualzing the server model:

\begin{figure}[h]
\[\begin{array}{l@{\;}r@{\;}l}
\validatorOf(p)&\triangleq&\existT{V}{\Set((\Nat\to\Var)\times\Set\constraint)}{\\
  &&(\vstep_p,\{(\_\mapsto\#0,\{\#0\equiv0\})\})}\\
\vstep_p(q,a,v)&\triangleq&\letin{v'}{v_0\gets v;\vstep'_p(q,a,v_0)}\\
&&\If v'\Is\varnothing\Then\None\Else\Some v'\hfill(\ref{rule:reject})\\
\vstep'_p(q,a,v_0)&\triangleq&\letin{v_1}{\Havoc(1,v_0)}\\
&&\letin{v_2}{\Write(0,q,v_1)}\\
&&(vs_3,cs_3)\gets\Exec(p,v_2);\\
&&\letin{cs_4}{cs_3\cup\{\#(vs_3!0)\equiv a\}}\hfill(\ref{rule:return})\\
&&\If\solvable cs_4\Then\{(vs_3,cs_4)\}\Else\varnothing\hfill(\ref{rule:unsat})\\
\Exec(p,(vs,cs))&\triangleq&\begin{cases}
  \{(vs,cs)\}&p\Is\Return\\
  \Exec(p',\Write(d,e,(vs,cs)))&p\Is !d\coloneqq e;p'\\
  \left(\begin{array}{@{}l}
    \letin{v_1}{(vs,cs\cup\{{e_1}^{vs}\le{e_2}^{vs}\})}\\
    \letin{v_2}{(vs,cs\cup\{{e_2}^{vs}<{e_1}^{vs}\})}\\
    \Exec(p_1,v_1)\cup\Exec(p_2,v_2)\hfill(\ref{rule:branch})
  \end{array}\right)&\begin{array}{@{}l}p\Is\\
    \If e_1\le e_2\\
    \tthen p_1\Else p_2\end{array}
\end{cases}\\
\Write(d,e,(vs,cs))&\triangleq&\letin{x_e}{\Fresh (vs,cs)}\hfill(\ref{rule:write})\\
&&(\update{vs}{d}{x_e},cs\cup\{\#x_e\equiv e^{vs}\})\\
\Havoc(d,(vs,cs))&\triangleq&\letin{x_c}{\Fresh (vs,cs)}(\update{vs}{d}{x_c},cs)\hfill(\ref{rule:choice})\\
e^{vs}&\triangleq&\begin{cases}
  n&e\Is n:\Nat\\
  \#(vs!src)&e\Is!src\\
  {e_1}^{vs}\oop{e_2}^{vs}&e\Is e_1\oop e_2
\end{cases}
\end{array}\]
\caption[Dualizing server model into validator]{Dualizing server model into
  validator, with derivation rules annotated.}
\label{fig:dualize}
\end{figure}

\begin{enumerate}
\item \label{rule:write} When the server performs a write operation
  $!dst\coloneqq exp$, the validator creates a fresh variable $x$ to represent
  the new value stored in address $!dst$, and adds a constraint that says $x$'s
  value is equal to that of $exp$.
\item \label{rule:branch} When the server makes a nondeterministic branch $\If
  e_1\le e_2\Then p_1\Else p_2$, consider both cases: (a) If $p_1$ was taken,
  then the validator should add a constraint $e_1\le e_2$; or (b) If $p_2$ was
  taken, then the validator should add constraint $e_2<e_1$.
\item \label{rule:choice} Before executing the program, the server writes the internal
    choice $c$ to address $!1$.  Accordingly, the validator creates a fresh
    variable to represent the new value stored in address $!1$, without adding
    any constraint.
\item \label{rule:return} After executing the program, the server sends back the
  value stored in $!0$ as response.  Accordingly, the validator adds a
  constraint that says the variable representing address $!0$ is equal to the
  observed response.
\item \label{rule:unsat} When the constraints of a validation state becomes
  unsatisfiable, it indicates that the server model cannot explain the
  observation.  This is because either (i) the observation is invalid {\it i.e.}
  not producible by the server model, or (ii) the observation is valid, but was
  produced by a different execution path of the server model.
\item \label{rule:reject} The validator accepts the trace if it can be produced
  by any execution path of the server model.  Since each execution path
  corresponds to a validation state, the validator only needs to remove the
  unsatisfiable state from the set of states.  If the set of validation states
  becomes empty, it indicates that the observation cannot be explained by any
  execution path of the specification, so the validator should reject the trace.
\end{enumerate}

This mechanism is formalized in \autoref{fig:dualize}.  Here notation
``$v_0\gets v;\vstep'_p(q,a,v_0)$'' is a monadic bind for sets: Let $\vstep'_p$
map each element $v_0$ in $v$ to a set of validation states
$(\vstep'_p(q,a,v_0):\Set((\Nat\to\Var)\times\Set\constraint))$, and return the
union of all result sets as $v'$.

The validator assumes a constraint solver that can determine whether a set of
constraints is satisfiable, {\it i.e.} whether there exists an {\em assignment}
of variables $(\Var\to\Int)$ that satisfy all the constraints:
\begin{gather*}
  \forall cs,\solvable cs\iff\exists (asgn:\Var\to\Int),\satisfy{asgn}cs\\
  \begin{array}{r@{\;}l}
    \satisfy{asgn}cs\triangleq&\forall(e_1\ccmp e_2)\in cs, {e_1}^{asgn}\ccmp{e_2}^{asgn}\\
    e^{asgn}\triangleq&\begin{cases}
      z&e\Is z:\Int\\
      asgn!x&e\Is \#x\\
      {e_1}^{asgn}\oop{e_2}^{asgn}&e\Is e_1\oop e_2
    \end{cases}
  \end{array}
\end{gather*}
Here ``$e^{asgn}$'' is pronounced ``evaluating validator expression $(e:\Vexp)$
with assignment $(asgn:\Var\to\Int)$''.  It substitutes all occurences of
``$\#x$'' with their assigned value $(asgn!x)$.

When the $\Prog$ model writes to memories or makes conditional branches, the
operands are represented as specification expressions ($\Sexp$) that refer to
server addresses.  To construct the constraints over symbolic variables, the
validator translates the expressions $(e:\Sexp)$ into validator expressions
$(e^{vs}:\Vexp)$ by {\em symbolizing} it with the validation state
$(vs:\Nat\to\Var)$, which substitutes all addresses $(!src)$ with their
corresponding variable $\#(vs!src)$.

\begin{figure}[h]
\begin{align*}
&\validatorOf(\texttt{CMP-RST})\triangleq\existT{V}{\Set((\Nat\to\Var)\times\Set\constraint)}\\
  &\begin{array}{rll}
     (&\lam{(q,a,v)}{&\llet v'=\begin{array}[t]{@{}l@{}l@{}ll}
       \multicolumn{3}{@{}l}{(vs_0,cs_0)\gets v;}\\
       \letin{vs_1&}{\update{vs_0}{1}{\Fresh (vs_0,cs_0)}&}&\text{(1)}\\
       \letin{x_q&}{\Fresh (vs_1,cs_0)&}\\
       \letin{vs_2&}{\update{vs_1}{0}{x_q}&}\\
       \letin{cs_2&}{cs_0\cup\{\#x_q\equiv q\}&}\\
       \letin{cs_{3a0}&}{cs_2\cup\{\#(vs_2!0)\le\#(vs_2!2))\}&}&\text{(2a)}\\
       \letin{x_{3a1}&}{\Fresh (vs_2,cs_{3a0})&}\\
       \letin{vs_{3a1}&}{\update{vs_2}{0}{x_{3a1}}&}\\
       \letin{cs_{3a1}&}{cs_{3a0}\cup\{\#x_{3a1}\equiv0\}&}\\
       \letin{cs_{3b0}&}{cs_2\cup\{\#(vs_2!2)<\#(vs_2!0)\}&}&\text{(2b)}\\
       \letin{x_{3b1}&}{\Fresh (vs_2,cs_{3b0})&}\\
       \letin{vs_{3b1}&}{\update{vs_2}{0}{x_{3b1}}&}\\
       \letin{cs_{3b1}&}{cs_{3b0}\cup\{\#x_{3b1}\equiv1\}&}\\
       \letin{x_{3b2}&}{\Fresh (vs_{3b1},cs_{3b1})&}\\
       \letin{vs_{3b2}&}{\update{vs_{3b1}}{2}{x_{3b2}}&}\\
       \letin{cs_{3b2}&}{cs_{3b1}\cup\{\#x_{3b2}\equiv\#(vs_{3b2}!1)\}&}\\
       \multicolumn{3}{@{}l}{((vs_4,cs_4)\gets\{(vs_{3a1},cs_{3a1}),(vs_{3b2},cs_{3b2})\};}&\text{(3)}\\
       \letin{cs_5&}{cs_4\cup\{\#(vs_4!0)\equiv a\}&}\\
       \multicolumn{3}{@{}l}{\If\solvable cs_5\Then\{(vs_4,cs_5)\}\Else\varnothing}\\
       \end{array}\\
       &&\iin\\
       &&\If v'\Is\varnothing\Then\None\Else\Some v'
     }\\
     ,&\multicolumn{2}{l}{\{(\_\mapsto\#0,\{\#0\equiv0\})\}})
   \end{array}
\end{align*}
\caption[Validator for protocol CMP-RST]{Validator for CMP-RST, derived from
  $\Prog$ model.  This program consists of three parts: (1) symbolizing the
  query and internal choice before executing the model, (2) considering both
  branches in the model program, propagating a validation state for each branch,
  (3) filtering the validation states by constraint satisfiability, removing
  invalid states.}
\label{fig:derived-validator}
\end{figure}

For example, by dualizing the $\Prog$ model for CMP-RST in
\autoref{sec:proglang}, we get a validator as shown in
\autoref{fig:derived-validator}.  Such derived validators are proven sound and
complete in the following section.

\section{Correctness Proof}
\label{sec:proof}
\input{proof}
