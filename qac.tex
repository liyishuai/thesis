To illustrate how to write specifications for testing purposes, this section
introduces the ``query-answer-choice'' (QAC) language family for specifying
network protocols that involve internal nondeterminism.

\subsection{Specifying protocols with server models}
Network protocols can be specified with ``reference implementations'' {\it i.e.}
model programs that exhibit the space of valid behaviors.  For client-server
systems such as WWW, we can specify networked servers as programs that receive
queries and compute the responses.  Here I model the server programs with a data
structure called state monad.

\begin{definition}[State monad]
  Let $S$ be the state type, $A$ be the result type, then type $(S\to A\times
  S)$ represents a computation that, given a pre state, yields a result and the
  post state.  This computation is pronounced a ``state monad with state type
  $S$ and result type $A$''.

  For example, let the state be a key-value mapping $(K\to V)$, then we can
  define \ilc{get} and \ilc{put} computations as follows:
  \begin{align}
    \tag{1}&\mathtt{get}:K\to((K\to V)\to V\times(K\to V))\\
    \tag{2}&\mathtt{get}(k)(f)\triangleq (f(k), f)\\
    \tag{3}&\mathtt{put}:K\times V\to((K\to V)\to ()\times(K\to V))\\
    \tag{4}&\mathtt{put}(k,v)(f)\triangleq((),\update f k v)
  \end{align}

  These function definitions should be read as:
  \begin{enumerate}
    \item The \ilc{get} function takes a key as argument, and constructs a
      state monad with state type $(K\to V)$ and result type $V$.
    \item Given argument $k$ of type $K$, $\mathtt{get}(k)$ takes a mapping $f$
      as pre state and yields the mapped value $f(k)$ as result.  The post state
      is the original mapping $f$ unchanged.
    \item The \ilc{put} function takes a key-value pair as argument, and
      constructs a state monad with state type $(K\to V)$ and result type $()$
      (unit type, which is similar to \inlinec{void} return type in C/Java
      functions).
    \item Given argument $(k,v)$ of type $(K\times V)$, $\mathtt{put}(k,v)$
      takes a mapping $f$ as pre state and substitues its value at key $k$ with
      $v$.  The post state is the substituted mapping $\update f k v$.
  \end{enumerate}
\end{definition}

Now we can define the server model in terms of state monad:

\begin{definition}[Deterministic server model]
  \label{def:qaserver}
  A deterministic server is an infinite loop whose loop body takes a query and
  produces a response.  The server definition consists of the loop body and an
  initial state:
  \[\mathsf{DeterministicServer}\triangleq\sigT{S}{(Q \to S \to A \times S) \times S}\]
  This type definition is pronounced as: A deterministic server has an initial
  state of some type $S$.  Its loop body takes a request of type $Q$ and
  computes a state monad with state type $S$ and result type $A$, where type $A$
  represents the response.

  Notice that the server's state type is existentially quantified~\cite{tapl},
  while its query and response types are not.  This is because a protocol
  specification only defines the space of valid traces, and doesn't require the
  implementation's internal state to be a specific type.

  An instance of server model is written as:
  \[\existT S \sigma (\sstep,state_0)\]
  This expression is pronounced as: The server state is of type $\sigma$.  Its
  loop body is function $\sstep$ (which has type $Q\to\sigma\to A\times\sigma$)
  and its initial state is $state_0$ (which has type $\sigma$).
\end{definition}

For example, consider a compare-and-set (CMP-SET) protocol: The server stores a
number \inlinec n.  If the client sends a request that is smaller than \inlinec
S, then the server responds with \inlinec 0.  Otherwise, the server sets
\inlinec n to the request and responds with \inlinec 1:
\begin{lstlisting}[style=customc]
  int n = 0;
  while (true) {
    int request = recv();
    if (request <= n) send(0);
    else { n = request; send(1); }
  }
\end{lstlisting}

Such a server can be modelled as:
\begin{align*}
  \existT{S}{\Int}{(&\lam{(q,n)}{\begin{cases}
        (0,s)&q\le n\\
        (1,q)&\mathrm{otherwise}
    \end{cases}},\\
    &0)}
\end{align*}

\begin{align*}
  &\mathsf{stepDeterministicServer}(q)(\existT{S}{\sigma}{(\sstep, state)})\triangleq\\
  &\qquad\letin{(a,state')}{\sstep(q)(state)} \\
  &\qquad(a, \existT{S}{\sigma}{(\sstep, state')})
\end{align*}

In general, servers' responses and transitions might depend on choices that are
invisible to the testers.  These choices include inter-implementation
nondetermism like algorithm design, and inter-execution nondeterminism like
random numbers and timestamps.
\begin{definition}[Nondeterministic server model]
  \label{def:server}
  Let $C$ be the space of invisible choices, then a nondeterministic server is
  specified as:
\begin{align*}
  &\Server\triangleq\sigT{S}{(Q \times C \times S \to A \times S) \times S} \\
  &\stepServer:Q\times C \times \Server \to A\times \Server \\
  &\stepServer(q,c,\existT{S}{\sigma}{(\sstep, state)})\triangleq\\
  &\qquad\letin{(a,state')}{\sstep(q,c,state)} \\
  &\qquad(a, \existT{S}{\sigma}{(\sstep, state')})
\end{align*}
\end{definition}

Consider changing the aforementioned CMP-SET into CMP-RST: When the
request is greater than \inlinec S, the server resets \inlinec S to a
random number:
\begin{lstlisting}[style=customc]
  int S = 0;
  while (true) {
    int request = recv();
    if (request <= S) send(0);
    else { S = rand(); send(1); }
  }
\end{lstlisting}
Its corresponding server model can be written as
\begin{align*}
  \existT{S}{\Int}{(&\lam{(q,c,s)}{
      \begin{cases}
        (0,s)& q\le s\\
        (1,c)&\mathrm{otherwise}
      \end{cases}
    },\\
    &0)}
\end{align*}

\subsection{Validating traces}
In the QAC language family, a trace is a list of $Q\times A$ pairs.  The
validator takes a trace and determines whether it is valid per the protocol
specification.
\begin{definition}[Trace validity]
  Trace $t$ is valid per protocol specification $s$ (written as ``$\valid s
  t$'') if and only if it can be {\em produced} by the specification {\it i.e.}
  server model:
  \[\valid s t\quad\triangleq\quad\exists s',\behaves s t s'\]
  Here the producibility relation in \autoref{sec:concepts} is expanded with an
  argument $s'$ representing the post-transition state, pronounced
  ``specification $s$ can produce trace $t$ and step to specification $s'$~'':
  \begin{enumerate}
  \item A server model can produce an empty trace and step to itself:
    \[\behaves s \nil s\]
  \item A server model can produce a non-empty trace if it can produce the head
    of the trace, and step to some server model that produces the tail of the
    trace:
    \[\behaves s {t+(q,a)} s_2\quad\triangleq\quad\exists s_1,\behaves s t s_1\wedge
    \exists c,\stepServer(q,c,s_1)=(a,s_2)\]
  \end{enumerate}
\end{definition}

The validator is encoded as an infinite loop, where the loop body is a state
monad that determines whether each $Q\times A$ pair is valid.
\begin{definition}[Validator]
Let $V$ be some validator state type, then a validator starts from an initial
state, takes a query and its corresponding response, determines whether the
interaction are valid, and computes the next validator state upon valid:
\begin{align*}
  &\Validator\triangleq\sigT{V}{(Q \times A \times V \to \option V) \times V} \\
  &\stepValidator:Q\times A \times \Validator \to \option \Validator \\
  &\stepValidator(q,a,\existT{V}{\beta}{(\vstep, state)})\\
  &\qquad\triangleq\begin{cases}
  \Some{(\existT{V}{\beta}{(\vstep,state')})} & \vstep(q,a,state)=\Some{state'} \\
  \None & \vstep(q,a,state)=\None
  \end{cases}
\end{align*}
\end{definition}

For example, a validator for the CMP-SET protocol is written as:
\begin{align*}
  \existT{V}{\Int}{(&\lam{(q,a,v)}{
      \begin{cases}
        \If a\Is 0\Then\Some v\Else\None&q\le v\\
        \If a\Is 1\Then\Some q\Else\None&\mathrm{otherwise}
      \end{cases}
    },\\
    &0)}
\end{align*}

\begin{definition}[Trace acceptance]
A validator accepts a trace if its step function {\em consumes} the entire
trace:
\[\accepts v t\quad\triangleq\quad\exists v',\behaves v t v'\]

Here the cossumability relation ``$\behaves v t v'$~'' is pronounced ``validator
$v$ can consume trace $t$ and step into validator $v'$~'':
\begin{enumerate}
\item A validator can consume an empty trace and step to itself:
  \[\behaves v\nil v\]
\item A validator consumes a non-empty trace if it can consume the head of the
  trace, and step to some validator that can consume the tail of the trace:
  \[\behaves v {t+(q,a)} v_2\quad\triangleq\quad\exists v_1,\behaves v t v_1\wedge
  \stepValidator (q,a,v_1)=\Some v_2\]
\end{enumerate}
\end{definition}

\subsection{Soundness and completeness of validators}
We can now phrase the correctness properties in \autoref{sec:concepts} in terms
of the QAC language family:
\begin{enumerate}
  \item A rejection-sound ({\it i.e.} acceptance-complete) validator consumes
    all traces that are producible by the protocol specification:
    \[\begin{array}{lrl}
      \rejSound v s&\triangleq&\forall t,\rejects v t\implies\invalid s t\\
      &\triangleq&\forall t,(\exists s',\behaves s t s')\implies\exists v',\behaves v t v'
    \end{array}\]
  \item A rejection-complete ({\it i.e.} acceptance-sound) validator only
    consumes traces that are producible by the protocol specification:
    \[\begin{array}{lrl}
      \rejComplete v s&\triangleq&\forall t,\invalid s t\implies\rejects v t\\
      &\triangleq&\forall t,(\exists v',\behaves v t v')\implies\exists s',\behaves s t s'
    \end{array}\]
\end{enumerate}
