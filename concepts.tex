Testers are programs that determine whether implementations are compliant or
not, based on its observations.  This section defines the basic concepts and
notations in interactive testing.

\begin{definition}[Implementations and Traces]
  {\em Implementations} are programs that can interact with their environment.
  {\em Traces} are the outputs and inputs during execution.\footnote{This
    chapter focuses on internal nondeterminism, and assumes no external
    nondeterminism.  The tester's observation is considered identical to the
    SUT's output.}  ``Implementation $i$ can {\em produce} trace $t$'' is
  written as ``$\behaves i t$''.
\end{definition}

\begin{definition}[Specification, Validity, and Compliance]
  A {\em specification} is a description of valid traces.  ``Trace $t$ is {\em
    valid} per specification $s$'' is written as ``$\valid s t$''.

  An implementation $i$ {\em complies} with a specification $s$ (written
  ``$\complies s i$'') if it only produces traces that are valid per the
  specification:
  \[\complies s i\quad\triangleq\quad\forall t,(\behaves i t)\implies\valid s t\]
\end{definition}

\begin{definition}[Tester components and correctness]
  A tester consists of (i) a {\em validator} that accepts or rejects traces, and
  (ii) a {\em test harness} that triggers different traces with various input.

  A tester is {\em correct} if its acceptances and rejections are sound and
  complete.  A tester is {\em rejection-sound} if it only rejects incompliant
  implementations; it is {\em rejection-complete} if it can reject all
  incompliant implementations, provided sufficient time of
  execution.\footnote{The semantics of ``soundness'' and ``completeness'' vary
    among contexts.  This thesis inherits terminologies from existing
    literature~\cite{Tretmans}, but explicitly use ``rejection-'' prefix for
    clarity.  ``Rejection soundness'' is equivalent to ``acceptance
    completeness'', and vice versa.}

  The tester's correctness is based on its components' properties: A
  rejection-sound tester requires its validator to be {\em rejection-sound}; A
  rejection-complete tester consists of (i) a {\em rejection-complete} validator
  and (ii) an {\em exhaustive} test harness that can eventually trigger invalid
  traces.
\end{definition}

\begin{definition}[Correctness of validators]
  A validator $v$ is {\em rejection-sound} with respect to specification $s$
  (written as ``$\rejSound v s$'') if it only rejects traces that are invalid
  per $s$:
  \[\rejSound v s\quad\triangleq\quad\forall t,\rejects v t\implies\invalid s t\]

  A validator $v$ is {\em rejection-complete} with respect to specification $s$
  (written as ``$\rejComplete v s$'') if it rejects all behaviors that are
  invalid per $s$:
  \[\rejComplete v s\quad\triangleq\quad\forall t,\invalid s t\implies\rejects v t\]
\end{definition}

The rest of this chapter shows how to build validators that can be proven sound
and complete.
