The Deep Specification project~\cite{deepspec} aims at building a web server and
guarantee its functional correctness with respect to formal specification of the
network protocol.

\http requests can be conditional: if the client has a local copy of some
resource and the copy on the server has not changed, then the server needn't
resend the resource.  To achieve this, an \http server may generate a short
string, called an ``entity tag'' (ETag), identifying the content of some
resource, and send it to the client:


\begin{center}
  \begin{minipage}[t]{.4\textwidth}
    \begin{lstlisting}[style=customc]
/* Client: */
GET /target HTTP/1.1
    \end{lstlisting}
  \end{minipage}\begin{minipage}[t]{.4\textwidth}
    \begin{lstlisting}[style=customc]
/* Server: */
HTTP/1.1 200 OK
ETag: "tag-foo"
... content of /target ...
    \end{lstlisting}
  \end{minipage}
\end{center}

The next time the client requests the same resource, it can include the ETag in
the GET request, informing the server not to send the content if its ETag still
matches:
\begin{center}
\begin{minipage}[t]{.4\textwidth}
\begin{lstlisting}[style=customc]
/* Client: */
GET /target HTTP/1.1
If-None-Match: "tag-foo"
\end{lstlisting}
\end{minipage}\begin{minipage}[t]{.4\textwidth}
\begin{lstlisting}[style=customc]
/* Server: */
HTTP/1.1 304 Not Modified
\end{lstlisting}
\end{minipage}
\end{center}
If the ETag does not match, the server responds with code 200 and the updated
content as usual.

Similarly, if a client wants to modify the server's resource atomically by
compare-and-swap, it can include the ETag in the PUT request as
\inlinec{If-Match} precondition, which instructs the server to only update the
content if its current ETag matches:
\begin{center}
  \begin{minipage}[t]{.4\textwidth}
    \begin{lstlisting}[style=customc]
/* Client: */
PUT /target HTTP/1.1
If-Match: "tag-foo"
... content (A) ...
    \end{lstlisting}
  \end{minipage}
  \begin{minipage}[t]{.4\textwidth}
    \begin{lstlisting}[style=customc]
/* Server: */
HTTP/1.1 204 No Content
    \end{lstlisting}
  \end{minipage}

  \begin{minipage}[t]{.4\textwidth}
    \begin{lstlisting}[style=customc]
/* Client: */
GET /target HTTP/1.1
    \end{lstlisting}
  \end{minipage}
  \begin{minipage}[t]{.4\textwidth}
    \begin{lstlisting}[style=customc]
/* Server: */
HTTP/1.1 200 OK
ETag: "tag-bar"
... content (A) ...
    \end{lstlisting}
  \end{minipage}
\end{center}
If the ETag does not match, then the server should not perform the requested
operation, and should reject with code 412:
\begin{center}
  \begin{minipage}[t]{.4\textwidth}
    \begin{lstlisting}[style=customc]
/* Client: */
PUT /target HTTP/1.1
If-Match: "tag-baz"
... content (B) ...
    \end{lstlisting}
  \end{minipage}
  \begin{minipage}[t]{.4\textwidth}
    \begin{lstlisting}[style=customc]
/* Server: */
HTTP/1.1 412 Precondition Failed
    \end{lstlisting}
  \end{minipage}

  \begin{minipage}[t]{.4\textwidth}
    \begin{lstlisting}[style=customc]
/* Client: */
GET /target HTTP/1.1
    \end{lstlisting}
  \end{minipage}
  \begin{minipage}[t]{.4\textwidth}
    \begin{lstlisting}[style=customc]
/* Server: */
HTTP/1.1 200 ok
ETag: "tag-bar"
... content (A) ...
    \end{lstlisting}
  \end{minipage}
\end{center}

If the tag does not match, the server responds with code 200 and the updated
content as usual.  Similarly, if a client wants to modify the server's resource
atomically by compare-and-swap, it can include the ETag in the PUT request as
\inlinec{If-Match} precondition, which instructs the server to only update the
content if its current ETag matches.

Thus, whether a server's response should be judged {\em valid} or not
depends on the ETag it generated
when creating the resource.  If the tester doesn't know the server's internal
state ({\it e.g.}, before receiving any 200 response including the ETag), and
cannot enumerate all of them (as ETags can be arbitrary strings), then it needs
to maintain a space of all possible values, narrowing the space upon further
interactions with the server.

\begin{figure}
  \begin{lstlisting}[style=customcoq,mathescape=true]
(* update : (K -> V) * K * V -> (K -> V) *)
let check (trace  : stream http_message,
           data   : key -> value,
           is     : key -> etag,
           is_not : key -> list etag) =
  match trace with
  | PUT(k,t,v) :: SUCCESSFUL :: tr' =>
    if t $\in$ is_not[k] then reject
    else if   is[k] == unknown
            $\vee$ strong_match(is[k],t)
         then let d' = update(data,k,v)     in
              let i' = update(is,k,unknown) in
              let n' = update(is_not,k,[])  in
       (* Now the tester knows that
        * the data in [k] is updated to [v],
        * but its new ETag is unknown. *)
              check(tr',d',i',n')
         else reject
  | PUT(k,t,v) :: PRECONDITION_FAILED :: tr' =>
    if strong_match(is[k],t) then reject
    else let n' = update(is_not, k, t::is_not[k])
      (* Now the tester knows that
       * the ETag of [k] is other than [t]. *)
         in check(tr',data,is,n')
  | GET(k,t) :: NOT_MODIFIED :: tr' =>
    if t $\in$ is_not[k] then reject
    else if is[k] == unknown $\vee$ weak_match(is[k],t)
         then let i' = update(is,k,t) in
       (* Now the tester knows that
        * the ETag of [k] is equal to [t]. *)
              check(tr',data,i',is_not)
         else reject
  | GET(k,t0) :: OK(t,v) :: tr' =>
    if weak_match(is[k],t0) then reject
    else if data[k] $\neq$ unknown $\wedge$ data[k] $\neq$ v
         then reject
         else let d' = update(data,k,v) in
              let i' = update(is,  k,t) in
       (* Now the tester knows
        * the data and ETag of [k]. *)
              check(tr',d',i',is_not)
  | _ :: _ :: _  => reject
  end
  \end{lstlisting}
  \caption{Ad hoc tester for \http conditional requests, demonstrating how
    tricky it is to write the logic by hand.  The checker determines whether a
    one-client-at-a-time \ilc{trace} is valid or not.  The trace is represented
    as a stream (infinite linked list, constructed by ``\ilc{::}'') of HTTP
    messages sent and received.
    \ilc{PUT(k,t,v)} represents a PUT
    request that changes \ilc{k}'s value into \ilc{v} only if its ETag matches
    \ilc{t}; \ilc{GET(k,t)} is a GET request for \ilc{k}'s value only if its
    ETag does not match \ilc{t}; \ilc{OK(t,v)} indicates the request target's
    value is \ilc{v} and its ETag is \ilc{t}.  The tester maintains three
    sorts of  knowledge about
    the server: \ilc{data} stored for each content, what some
    ETag \ilc{is} known to be equal to, and what some ETag \ilc{is_not} equal
    to.
  }
  \label{fig:etag-tester}
\end{figure}

It is possible, but tricky, to write an ad hoc tester for \http by manually
``dualizing'' the behaviors described by the informal specification documents
(RFCs).  The protocol document describes {\em how} a valid server should handle
requests, while the tester needs to determine {\em what} responses received from
the server are valid.  For example, ``If the server has revealed some resource's
ETag as \inlinec{"foo"}, then it must not reject requests targetting this
resource conditioned over \inlinec{If-Match: "foo"}, until the resource has been
modified''; and ``Had the server previously rejected an \inlinec{If-Match}
request, it must reject the same request until its target has been modified.''
\autoref{fig:etag-tester} shows a hand-written tester for checking this bit of
ETag functionality; we hope the reader will agree that this testing logic is not
straightforward to derive from the informal ``server's eye'' specifications.

Networked systems are naturally concurrent, as a server can be connected with
multiple clients.  The network might delay packets indefinitely, so messages
sent via different channels may be reordered during transmission.  When the
tester observes messages sent and received on the client side, it should allow
all observations that can be explained by the combination of a valid server + a
reasonable network environment between the server and clients.
