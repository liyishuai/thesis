So far we have introduced the QAC language family for representing servers and
validators, and demonstrated the derivation mechanism with a $\Prog$ language.
Next I'll show how to prove that QAC validators are sound and complete:
\[\begin{array}{r@{\;}l}
\forall p:\Prog,&\letin{s}{\serverOf(p)}\\
&\letin{v}{\validatorOf(p)}\\
&\rejSound v s\wedge\rejComplete v s\\
&\text{\it i.e. }\forall t:\List(Q\times A),\\
&\qquad\valid s t\iff\accepts v t\\
&\qquad\text{\it i.e. }\exists s',\behaves s t s'\iff\exists v',\behaves v t v'
\end{array}\]

This section first presents a generic framework for proving validators'
correctness properties, and then demonstrates its usage by applying it to
$\Prog$-based validators.

\subsection{Proof strategy}
Both the specification and the validator are infinite loops, and the correctness
property is defined as equivalence between production and consumption of traces.
Therefore, we can prove this bisimulation relation by introducing some loop
invariant, and show that it is preserved in each step between the specification
and the validator.

\paragraph{Rejection soundness (acceptance completeness)}
To prove that any trace producible by server $\existT{S}{\sigma}{(\sstep,s_0)}$
is consumable by validator $\existT{V}{\beta}{(\vstep,v_0)}$, we need forward
induction on the server's execution path, and show that every step has a
corresponding validator step:
\begin{itemize}
\item The initial server state $s_0$ reflects the initial validator state $v_0$:
  \begin{equation}
    \tag{RejSound-Init}
    \label{eq:rs1}
    \Reflects{(v_0:\beta)}{(s_0:\sigma)}
  \end{equation}
\item Any server step $\sstep(q,c,s)=(a,s')$ whose pre-execution state $s$
  reflects some pre-validation state $v$ can be consumed by the validator
  into a post-validation state $v'$ that reflects the post-execution state $s'$:
  \begin{align*}
    \tag{RejSound-Step}
    \label{eq:rs2}
    &\forall(q:Q)(c:C)(a:A)(s,s':\sigma)(v:\beta),\\
    &\sstep(q,c,s)=(a,s')\wedge\Reflects{v}{s}\\
    &\implies\exists v':\beta,\vstep(q,a,v)=\Some{v'}\wedge\Reflects{v'}{s'}
  \end{align*}
  \begin{center}
    \includegraphics[width=.5\textwidth]{figures/sound}
  \end{center}
\end{itemize}

\paragraph{Rejection completeness (acceptance soundness)}
To prove that any trace consumable by validator
$\existT{V}{\beta}{(\vstep,v_0)}$ is producible by server
$\existT{S}{\sigma}{(\sstep,s_0)}$, we need backward induction on the
validator's execution path, and show that every step has a corresponding server
step:
\begin{itemize}
\item Any accepting validator step $\vstep(q,a,v)=\Some v'$ has some server
  state $s'$ that reflects the post-validation state $v'$:
  \begin{align*}
    \tag{RejComplete-End}
    \label{eq:rc1}
    \forall(q:Q)(a:A)(v, v':\beta),\;&\vstep(q,a,v)=\Some{v'}\\
    &\implies\exists s':\sigma,\Reflects{v'}{s'} 
  \end{align*}
\item Any accepting validator step $\vstep(q,a,v)=\Some v'$ whose
  post-validation state $v'$ reflects some post-execution server state $s'$
  has a corresponding server step from a pre-execution state $s$
  that reflects the pre-validation state $v$:
  \begin{align*}
    \tag{RejComplete-Step}
    \label{eq:rc2}
    &\forall(q:Q)(a:A)(v,v':\beta)(s':\sigma),\\
    &\vstep(q,a,v)=\Some{v'}\wedge\Reflects{v'}{s'}\\
    &\implies\exists(s:\sigma)(c:C),\sstep(q,c,s)=(a,s')\wedge\Reflects{v}{s}
  \end{align*}
  \begin{center}
    \includegraphics[width=.5\textwidth]{figures/complete}
  \end{center}

\item The initial validator state $v_0$ only reflects the initial server state $s_0$:
  \begin{equation}
    \tag{RejComplete-Init}
    \label{eq:rc3}
    \{s\mid\Reflects{v_0}{s}\}=\{s_0\}
  \end{equation}
\end{itemize}

Rejection soundness is proven by forward induction, while rejection completeness
is proven by backward induction.  This is because the choice $C$ is known from
the server step, but unknown from the validator step: Given a validator step, we
cannot predict ``what choices the server will make in the future'', but can
analyze ``what choices the server might have made in the past''.  This proof
strategy is further explained with the $\Prog$ example.

\subsection{Case study: Proving $\Prog$-based validators' correctness}
For specifications written in the $\Prog$ language, the validator is derived by
dualizing the server model.  It maintains a set of validation states, each state
corresponds to a possible execution path of the model program.

A validation state is accepting if its constraints are satisfiable, {\it i.e.}
there exists an assignment of the symbolic variables that can unify the trace
with the server model.

The validator accepts the trace if any of its validation states is accepting,
which indicates that some execution path of the server model can produce the
trace.

Given an accepting validation state, we can construct the server steps that
produce the trace, using the assignment $(\Var\to\Int)$ that satisfies the
constraints.  This assignment evaluates internal choices' symbolic variables
into concrete values, and evaluates the validator's key-variable mapping
$(\Nat\to\Var)$ to the server's key-value mapping $(\Nat\to\Int)$.

Therefore, we only need to show that each server and validator step preserves
the existence of such assignment that relates their states.

For the rest of this section, $\beta=\Set((\Nat\to\Var)\times\Set\constraint)$
represents the validator state type, and $\sigma=\Nat\to\Int$ represents the
server state type.

\begin{definition}[Invariant between $\Prog$-based specification and validator]
  Validator state $v$ {\em simulates} server state $s$ if it contains a
  validation state $(vs,cs)$ that {\em reflects} the server state, {\it i.e.}
  (1) There exists an assignment $asgn$ that can satisfy the constraints $cs$;
  and (2) The key-variable mapping $vs$ can be evaluated with $asgn$ (written as
  $vs^{asgn}$) into a key-value mapping that is equivalent with
  $s$:
  \[\begin{array}{lll} \Reflects{(v:\beta)}{(s:\sigma)}&\triangleq&
  \exists((vs,cs)\in v)(asgn:\Var\to\Int),\satisfy{asgn} cs\wedge vs^{asgn}\equiv s\\
  vs^{asgn}&\triangleq&addr\mapsto asgn!(vs!addr) \end{array}\]
\end{definition}

\begin{lemma}[\ref{eq:rs1}]
\[\begin{array}{ll}
\text{If:}&
vs=(\_\mapsto\#0)\qquad
cs=\{\#0\equiv0\}\qquad
s=(\_\mapsto0)\\
\text{Then:}&\Reflects{\{(vs,cs)\}}{s}
\end{array}\]
\end{lemma}
\begin{proof}
Since $(vs,cs)$ is the only element in the validator state, we only need to show
that:
\[\exists(asgn:\Var\to\Int),\satisfy{asgn} cs\wedge vs^{asgn}\equiv s\]

By constructing the assignment as: \[asgn=(\_\mapsto0)\]

We have: \[\#0^{asgn}=0\]

Thus: \[\satisfy{asgn} cs\]

We also know that: \[\forall k, asgn!(vs!k)=0=(s!k)\]

Thus: \[vs^{asgn}\equiv s\]
\end{proof}

\begin{lemma}[\ref{eq:rs2}]
  \begin{align*}
    &\forall(p:\Prog)(q,c,a:\Int)(s,s':\sigma)(v:\beta),\\
    &\sstep_p(q,c,s)=(a,s')\wedge\Reflects{v}{s}\\
    &\implies\exists v':\beta,\vstep_p(q,a,v)=\Some{v'}\wedge\Reflects{v'}{s'}
  \end{align*}
\begin{proof}
The invariant $\Reflects{v}{s}$ tells us that $v$ contains a validation state
that reflects the server state $s_0$:
\[\exists((vs,cs)\in v)(asgn:\Var\to\Int),\satisfy{asgn} cs\wedge {vs}^{asgn}\equiv s\]

Since the server's internal choice was provided, we can compute the server's
actual execution path.  For each small step of the server's execution, we can
construct its corresponding validator small step, based on the derivation rules
in \autoref{sec:dualization}.  By making the same internal choice and branch
decisions as the server did, we can construct the assignment that unifies the
validator with the server.  The proof details are shown in \autoref{sec:rs2-proof}.
\end{proof}
\end{lemma}

\begin{lemma}[\ref{eq:rc1}]
\begin{align*}
\forall(p:\Prog)(q,a:\Int)(v,v':\beta),\;&\vstep_p(q,a,v)=\Some{v'}\\
&\implies\exists s':\sigma,\Reflects{v'}{s'}
\end{align*}
\begin{proof}
Since $\vstep_p$ checks the nonemptiness of the result, we know that $v'$ must
be nonempty.  Consider validation state $(vs',cs')\in v'$.  Since $\vstep_p'$
checks that $(\solvable cs')$, we know that:
\[\exists asgn,\quad\satisfy{asgn}cs'\]

Let:
\[s'=vs'^{~asgn}\]

Then we have:
\begin{align*}
&(vs',cs')\in v'\wedge \satisfy{asgn}{cs'}\wedge vs'^{~asgn}\equiv s'\\
&\textit{i.e. }\Reflects{v'}{s'}
\end{align*}
\end{proof}
\end{lemma}

\begin{lemma}[\ref{eq:rc2}]
\begin{align*}
&\forall(p:\Prog)(q,a:\Int)(v,v':\beta)(s':\sigma),\\
&\vstep_p(q,a,v)=\Some{v'}\wedge\Reflects{v'}{s'}\\
&\implies\exists(s:\sigma)(c:\Int),\sstep_p(q,c,s)=(a,s')\wedge\Reflects{v}{s}
\end{align*}
\end{lemma}

This bisimulation definition satisfies the hypotheses for proving soundness and
completeness:

Hypotheses~\ref{eq:rs1} and \ref{eq:rc3} are immediate from the initial states'
definition: The initial server state is all-zero map.  The initial validator
state is a singleton that maps all addresses to a variable that is constrained
to have value zero.

\autoref{eq:rc1} is based on the fact that $\vstep_p$ checks the nonemptiness of
the result:
\[\forall q~a~v~v',\vstep_p(q,a,v)=\Some{v'}\implies(\vstep_p'(q,a,v)=v'\wedge\exists (vs,cs)\in v')\]
and that $\vstep_p'$ guards the satisfiability of all constraints in its result:
\[\forall q~a~vs~cs,{(vs,cs)}\in\vstep_p'(q,a,v)\implies\exists asgn,\satisfy{asgn}cs\]

Therefore, any element in the resulting validator state can construct a
simulating server state:
\[\forall asgn~cs~vs~v,(\satisfy{asgn}cs\wedge(vs,cs)\in v)\implies \Reflects{v}{vs^{asgn}}\]

\autoref{eq:rc3} observes that validator design increases the constraints
monotonically.  Therefore, ``assignments that can satisfy the post-validation
constraints'' is a subset of ``assignments that can satisfy the pre-validation
constraints'':
\[\forall q~a~vs~cs~vs'~cs'~asgn,((vs',cs')\in\vstep_p'(q,a,(vs,cs))\wedge\satisfy{asgn} cs')\implies\satisfy{asgn}cs\]

As a result, the corresponding pre-step server state and the internal choice can
be constructed, and proven to perform the server-side step:
\begin{align*}
\forall q~a~vs~cs~vs'~cs'~asgn,\;&(vs',cs')\in\vstep_p'(q,a,(vs,cs))\\
&\implies\sstep_p(q,asgn!(\Fresh{vs}),vs^{asgn})=vs'^{~asgn}
\end{align*}

The intuition here is that the assignment includes ``all choices made by the
server, past and future'', which is narrowed upon more and more observations.
Therefore, the assignment can instantiate all previous validator states into
corresponding servers, and reconstruct the server's execution path by inferring
its internal choices.
