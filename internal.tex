This section applies the dualization theory in \autoref{chap:theory} to the
ITree context.  I'll show how to perform symbolic evaluation by interpreting
ITree programs.

\autoref{sec:symbolic-model} explains how to represent systems' internal choices
as ITree's symbolic events.  It fills in the \ilc{\{E\}} hole in
\autoref{fig:net-compose-code}, and constructs the ``Symbolic Model'' box in
\autoref{fig:framework}.  \autoref{sec:dualize-interaction} and
\autoref{sec:symbolic-eval} takes the observer-side specification composed in
\autoref{sec:net-compose} and interprets it into a tester model, covering the
``Dualization'' and ``Unification'' arrows in the derivation framework.

\subsection{Symbolizing internal choices}
\label{sec:symbolic-model}
The key idea of language design is to expose symbolic representations to the
dualzation algorithm.  The $\Prog$ language in \autoref{sec:proglang} encodes
data as symbolic expressions $\Sexp$, so that the responses and branch
conditions may depend on internal choices.  I do the same for ITree
specifications, by symbolizing the choice events and branch conditions.  Take my
HTTP specification~\cite{issta21} as an example, its choice event has symbolic
expression as result type:

\begin{coq}
  Variant comparison := Strong | Weak.

  Variant exp: Type -> Type :=
    Const    : string -> exp string
  | Var      : var    -> exp string
  | Compare  : string -> exp string -> comparison -> exp bool.

  Variant choiceE: Type -> Type :=
    Choice: symE (exp string).
\end{coq}

Here I instantiate the \ilc{choiceE} in \autoref{sec:itree-lang} with symbolic
return type \ilc{(exp string)}, pronounced ``expression of type string''.  In
this example, I use strings to represent entity tags (ETags) that HTTP servers
may generate, which was discussed in \autoref{sec:internal-nondeterminism}.  The
type interface can be adjusted to other protocols under test.

Symbolic expressions may be constructed as constant values, as variables, or
with operators.  The \ilc{Compare} constructor takes an expression of type
string and compares it against a constant string.  \ilc{(Compare t tx cmp)}
represents the ETag comparison between \ilc{t} and \ilc{tx}, using ``strong
comparison'' or ``weak comparison'' mechanism~\cite{rfc7232} specified by
\ilc{cmp}.  The constant ETag is provided by the request, and the symbolized one
comes from the server state.

\begin{figure}
\begin{coq}
  CoFixpoint server (state: path -> resource) :=
    q <- trigger Recv;;
    let v : content    := q.(Payload)      in
    let k : path       := q.(TargetPath)   in
    let t : string     := q.(IfMatch)      in
    let tx: exp string := (state k).(ETag) in
    IFX (Compare t tx Strong)
    THEN
      if q.(Method) is Put
      then
        tx' <- trigger Choice;;
        let state' := state [k |-> {Content := v; ETag := tx'}] in
        trigger (Send OK);;
        server state'
      else                 (* handling other kinds of requests *)
        (a, state') <- process q state;;
        trigger (Send a);;
        server state'
    ELSE
      trigger (Send PreconditionFailed);;
      server s.
\end{coq}
\caption{Server model for HTTP conditional requests}
\label{fig:if-match-server}
\end{figure}

\autoref{fig:if-match-server} shows an ITree model for If-Match requests in
\autoref{sec:internal-nondeterminism}.  The server first evaluates the request's
\inlinec{If-Match} condition by ``strong comparison'' as required by HTTP.  If
the request's ETag matches its target's, then the server updates the target's
contents with the request payload.  The target's new ETag \ilc{tx'} can be of
any value, so the model represents it as \ilc{Choice} event.

Notice that the server model exhibits two kinds of branches: (1) The \ilc{if}
branches are provided by the ITree's embedding language Coq, which takes a
boolean value as condition; (2) The \ilc{IFX} branches are constructors of
ITrees with nondeterministic branches, where the condition is a symbolic
expression of type bool:
\begin{coq}
  Variant branchE: Type -> Type :=
    Decide: exp bool -> branchE bool.

  Notation "IFX condition THEN x ELSE y" :=
    (b <- trigger (Decide condition);;
     if b then x else y).
\end{coq}

These two kinds of branch conditions play different roles in the specification,
and will be handled differently during testing:
\begin{enumerate}
\item The ``pure'' \ilc{if} condition is used for deterministic branches like
  \ilc{(q.(Method) is Put)} in the example.  Here \ilc q is a ``concrete
  request''\footnote{In this chapter, ``concrete'' messages are those that don't
    involve symbolic variables, as opposed to ``symbolic'' messages.} generated
  by the tester and sent to the server, so its method is known by the tester and
  needn't be symbolically evaluated.
\item The ``symbolic'' \ilc{IFX} condition here plays a similar rule as the
  $\mathsf{if}$ branches in the $\Prog$ language: Which branch to take depends
  on the server's internal choices, so the tester needs to consider both cases.
\end{enumerate}

Now we can fill the hole \ilc{\{E\}} in \autoref{fig:net-compose-code}.  The
server model receives concrete requests and sends symbolic responses, so its
event type is defined as:
\begin{coq}
  Record packet := {
    source      : connection;
    destination : connection;
    payload     : request + symbolic_response
  }.

  Variant qaE: Type -> Type :=
    Recv : qaE packet
  | Send : packet -> qaE unit.
\end{coq}

The HTTP server, for example, can be modelled as:
\begin{coq}
  Definition server_http: itree (qaE +' choiceE +' branchE) void :=
    server init_state.
\end{coq}

The server model is then transformed via network composition into a symbolic
model for test derivation purposes:
\begin{coq}
  (* Observer-side symbolic model's event type: *)
  Notation smE := (netE +' nondetE +' choiceE +' branchE).
  
  Definition sm_http: itree smE void :=
    compose server_http tcp [] [].
\end{coq}

This corresponds to the ``Symbolic Model'' in \autoref{fig:framework}.  The rest
of this section will explain the interpretations from this symbolic model.

\subsection{Dualizing interactions}
\label{sec:dualize-interaction}
This subsection takes the symbolic model composed in
\autoref{sec:symbolic-model} and dualizes its interactions, which corresponds to
the ``Dualization'' arrow in \autoref{fig:framework}.  It applies the derivation
rules (\ref{rule:write})--(\ref{rule:return}) for $\Prog$ in
\autoref{sec:dualize-prog} to models written as ITrees.

This interpretation phase produces a symbolic observer that models the tester's
observation and validation behavior.  The observer sends a request when the
server wants to receive one, and receives a response when the server wants to
send one.  It also creates constraints over the server's internal choices based
on its observations.

\autoref{fig:symbolic-observer} shows the dualization algorithm.  It interprets
the symbolic model's events with the \ilc{observe} handler, whose types are
explained as follows:

\begin{figure}
\begin{lstlisting}[style=customcoq,numbers=left,escapechar=\%]
Notation oE := (observeE +' nondetE +' choiceE +' constraintE).

Definition observe {R} (e: smE R) : itree oE R :=
  match e with
  | (Absorb |)     => trigger FromObserver%\label{line:observe-absorb}%
  | (Emit px|)     => p <- trigger ToObserver;;%\label{line:observe-emit}%
                      trigger (Guard px p)
  | (|||Branch bx) => or (trigger (Unify bx true);;  ret true)%\label{line:observe-branch}%
                         (trigger (Unify bx false);; ret false)
  | (|Or|)         => trigger Or%\label{line:observe-or}%
  | (||Choice|)    => trigger Choice%\label{line:observe-choice}%
  end.

Definition observer_http: itree oE void :=
  interp observe sm_http.
\end{lstlisting}
\caption{Dualizing symbolic model into symbolic observer.}
\label{fig:symbolic-observer}
\end{figure}

The tester observes a trace of concrete packets, so observer's interactions
return concrete requests and responses, as opposed to the symbolic model whose
responses are symbolic.
\begin{coq}
  Record concrete_packet := {
    source      : connection;
    destination : connection;
    payload     : request + concrete_response
  }.

  Variant observeE : Type -> Type :=
    FromObserver   : observeE concrete_packet
  | ToObserver     : observeE concrete_packet.
\end{coq}

Notice that the observer's send and receive events both return the packet sent
or received, unlike the server model whose \ilc{Send} event takes the sent
packet as argument.  This is because the tester needs to generate the request
packet to send, and the event's result value represents that generated and sent
packet.

As discussed in \autoref{sec:dualize-prog}, when the server sends a symbolic
response or branches over a symbolic condition, the tester needs to create
symbolic constraints accordingly.  The observer introduces ``constraint events''
for this derivation rule:
\begin{coq}
  Variant constraintE : Type -> Type :=
    Guard : packet -> concrete_packet -> constraintE unit
  | Unify : exp bool -> bool -> constraintE unit.
\end{coq}

Here \ilc{(Guard px p)} creates a constraint that the symbolic packet \ilc{px}
emitted by the specification matches the concrete packet \ilc p observed during
runtime.  \ilc{(Unify bx b)} creates a constraint that the symbolic branch
condition \ilc{bx} is unifiable with boolean value \ilc b.  These constraints
will be solved in \autoref{sec:symbolic-eval}.

The dualization algorithm in \autoref{fig:symbolic-observer} does the follows:
\begin{enumerate}
  \item When the symbolic model absorbs a packet in
    \autoref{line:observe-absorb}, the observer generates a request packet;
  \item When the symbolic model emits a symbolic packet \ilc{px} in
    \autoref{line:observe-emit}, the observer receives a concrete packet \ilc p,
    and adds a constraint that restricts the symbolic and concrete packets match
    each other.
  \item When the symbolic model branches on a symbolic condition \ilc{bx} in
    \autoref{line:observe-branch}, the tester accepts the observation if it can
    be explained by any branch.  This is done by constructing the observer as a
    nondeterministic program that has both branches, using the \ilc{or}
    combinator.  For each branch, the observer adds a constraint that the
    symbolic condition matches the chosen branch.
  \item Nondeterministic branches in \autoref{line:observe-or} are preserved in
    this interpretation phase, and will be resolved in \autoref{sec:backtrack}.
  \item Internal choices in \autoref{line:observe-choice} are addressed by the
    next phase in \autoref{sec:symbolic-eval}, along with the constraints
    created in this phase.
\end{enumerate}

The result of dualization is a symbolic observer that models the tester's
behavior like sending requests and receiving responses.  The symbolic observer
is a nondeterministic program with primitives events like making choices and
adding constraints over the choices.  The rest of this chapter instantiates the
primitive events and resolves the nondeterministic branches, and executes it as
an interactive tester.

\subsection{Symbolic evaluation}
\label{sec:symbolic-eval}
This subsection takes the symbolic observer produced in
\autoref{sec:dualize-interaction} and solves the constraints it has created.
The constraints unify symbolic packets and branch conditions against the
concrete observations.  The tester should accept the SUT if the constraints are
satisfiable.

\begin{figure}
\begin{lstlisting}[style=customcoq,numbers=left,escapechar=\%]
Notation ntE := (observeE +' nondetE +' exceptE).

Definition V: Type := list var * list (constraintE unit).
  
Definition unify {R} (e: oE R) (v: V) : itree ntE (V * R) :=
  let (xs, cs) := v in
  match e with
  | (||Choice|)     => let x: var := fresh v in%\label{line:unify-choice}%
                       ret (x::xs, cs, Var x)
  | (|||constraint) => let cs' := constraint::cs in%\label{line:unify-constraint}%
                       if solvable cs'
                       then ret (xs, cs', tt)
                       else Trigger (Throw ("Conflict: " ++ print cs'))
  | (|Or|) => b <- trigger Or;; ret (v, b)%\label{line:unify-or}%
  | (oe|)  => r <- trigger oe;; ret (v, r)%\label{line:unify-observe}%
  end.

Definition nondet_tester_http: itree ntE void :=
  (_, vd) <- interp_state unify observer_http initV;;
  match vd in void with end.
\end{lstlisting}
\caption{Resolving symbolic constraints.}
\label{fig:nondet-tester}
\end{figure}

As shown in \autoref{fig:nondet-tester}, the unification algorithm evaluates the
primitive symbolic events into a stateful checker program, which reflects the
$\Prog$-based validator in \autoref{sec:dualize-prog}.  The interpretor
maintains a validation state \ilc V which stores the symbolic variables and the
constraints over them.  The derivation rules are as follows:
\begin{enumerate}
  \item When the server makes an internal choice in \autoref{line:unify-choice},
    the tester creates a fresh variable and adds it to the validation state.
  \item When the observer creates a constraint in
    \autoref{line:unify-constraint}, the tester adds the constraint to the
    validation state, and solves the new set of constraints.  If the constraints
    become unsatisfiable, then the tester \ilc{Throw}s an exception that
    indicates the current execution branch cannot accept the observations:
\begin{coq}
  Variable exceptE: Type -> Type :=
    Throw: forall {X}, string -> exceptE X.
\end{coq}      
  \item The observer is a nondeterministic program with multiple execution
    paths, constructed by \ilc{Or} events in \autoref{line:unify-or}.  The
    tester accepts the observation if any of the branches does not throw an
    exception.  These branches will be handled in the next section, along with
    the observer's send/receive interactions in \autoref{line:unify-observe}.
\end{enumerate}

Notice that the \ilc{unify} function interprets a symbolic observer's event
\ilc{(oE R)} into a state monad transformer \ilc{(V -> itree tE (V * R))}.  It
makes a step from pre-validation state \ilc{(v: V)} to post-validation state
\ilc{(v': V)}, and yields the event's corresponding result \ilc{(r: R)}.  Such
stateful interpretation process is handled by \ilc{interp_state}:
\begin{coq}
  CoFixpoint interp_state {E F V R}
                          (handler: forall {X}, E X -> V -> itree F (V * X))
                          (m: itree E R) (v: V)
             : itree F (V * R) :=
    match m with
    | Pure   r   => ret (v, r)
    | Impure e k => '(v', r) <- handler e v;;
                    interp_state handler (k r) v'
    end.
\end{coq}

So far I have interpreted the specification into a tester model that observes
incoming and outgoing packets, nondeterministically branches, and in some cases
throws exceptions.  The rest of this chapter will show how to execute this ITree
program on a deterministic machine and interact with the SUT.
