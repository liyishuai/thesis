This section applies the idea of dualization in \autoref{chap:dualize} to the
ITree context, showing how to address internal nondeterminism by symbolic
evaluation based on ITree specifications.  It covers the derivation path from
``symbolic model'' to ``nondeterministic tester'' in \autoref{fig:framework},
using \http entity tags introduced in \autoref{sec:internal-nondeterminism} as
an example.

As discussed in \autoref{sec:encode-spec}, dualization requires refining the
representation of the server's computation {\it e.g.} encoding its branches over
symbolic conditions.  This is done by designing ITrees' event types in
\autoref{sec:symbolic-model} and specifying the server's behavior with a
symbolic model.

The server specification is derived into a tester client by {\em interpreting}
interaction trees.  To interpret is to define semantic rules that transform one
ITree program into another, and corresponds to the arrows in
\autoref{fig:framework}.  \autoref{sec:interp} explains the interpretation of
ITrees.

The interpretation from symbolic model to the nondeterministic tester model is
implemented in two phases, illustrated as ``dualization'' and ``unification''
arrows in \autoref{fig:framework}: \autoref{sec:dualize-interaction} dualizes
the server's behavior into the tester client's, resulting in a ``symbolic
observer'' that encodes symbolic evaluation as primitive events.
\autoref{sec:symbolic-eval} then instantiates the primitive events into
pure computations that unify concrete observations against their symbolic
representations.

\subsection{Symbolic server model}
\label{sec:symbolic-model}
The server specification is an ITree program that exhibits all valid behavior of
the protocol.  I combine the $\Prog$ language in \autoref{sec:prog-lang} with the
simplistic ITree example in \autoref{sec:qac-itree}.

\paragraph{Network packet type}
Instead of receiving requests and sending responses, the server receives and
sends {\em packets} that carry routing information.  This allows us to specify
the server's interaction against concurrent clients in
\autoref{sec:external-nondet}.  A packet consists of headers that indicate its
source and destination, and a payload of either a request or a response:
\begin{coq}
  Notation connection := N. (* N for natural number *)

  Record packet Q A := {
    Source      : endpoint;
    Destination : endpoint;
    Payload     : Q + A
  }.
\end{coq}
This type definition says: the \ilc{packet} type is parameterized over the \ilc
Q and \ilc A types that represent its request and response.  Its \ilc{Source}
and \ilc{Destination} fields each records an \ilc{endpoint} represented as a
natural number.  Its \ilc{Payload} type is the sum of request and response.

Here's an example trace of network packets:
\begin{coq}
  Context get: string -> request.
  Context ok : string -> response.

  Definition server_end: endpoint := 0.

  Example trace: list (packet request response) :=
    [ { Source      := 1;
        Destination := server_end;
        Payload     := inl (get "/index.html")
      }
    ; { Source      := server_end;
        Destination := 1;
        Payload     := inr (ok "<p>Hello!</p>")
      }
    ].
\end{coq}
This trace encodes a transaction between client 1 and the server (represented as
endpoint 0).  The client sends a GET request to fetch the resource in path
\ilc{"/index.html"}, and the server responds with 200 OK and content
\ilc{"<p>Hello!</p>"}.  The \ilc{inl} and \ilc{inr} are constructors for sum
types:
\begin{coq}
  Context inl: forall {X Y}, X -> X + Y.
  Context inr: forall {X Y}, Y -> X + Y.
\end{coq}

\paragraph{Symbolic representation}
To specify systems' nondeterministic behavior, the $\Prog$ language in
\autoref{sec:prog-lang} encodes data as symbolic expressions $\Sexp$, so that
the responses and branch conditions may depend on internal choices.  I do the
same for ITree specifications, by symbolizing the choice events and branch
conditions.  Take my HTTP specification~\cite{issta21} as an example.  Its
choice event has symbolic expression as result type:

\begin{coq}
  Variant comparison := Strong | Weak.

  Variant exp: Type -> Type :=
    Const    : string -> exp string
  | Var      : var    -> exp string
  | Compare  : string -> exp string -> comparison -> exp bool.

  Variant choiceE: Type -> Type :=
    Choice: choiceE (exp string).
\end{coq}

Here I instantiate the \ilc{choiceE} in \autoref{sec:itree-lang} with symbolic
return type \ilc{(exp string)}, pronounced ``expression of type string''.  In
this example, I use strings to represent entity tags (ETags) that HTTP servers
may generate, which was discussed in \autoref{sec:internal-nondeterminism}.  The
type interface can be adjusted to other protocols under test.

Symbolic expressions may be constructed as constant values, as variables, or
with operators.  The \ilc{Compare} constructor takes an expression of type
string and compares it against a constant string.  \ilc{(Compare t tx cmp)}
represents the ETag comparison between \ilc{t} and \ilc{tx}, using ``strong
comparison'' or ``weak comparison'' mechanism\footnote{\http servers may choose
to generate ETags as ``strong validators'' (with uniqueness guarantee) or ``weak
validators'' (for potentially better performance).  When handling
compare-and-swap operations such as PUT requests conditioned over
\inlinec{If-Match} in \autoref{sec:internal-nondeterminism}, the server should
evaluate its precondition with ``strong comparison'' that don't allow weak
validators to match any ETag.  For GET requests conditioned over
\inlinec{If-None-Match}, the server may evaluate with ``weak comparison'' where
a weak validator may match another ETag.} specified by \ilc{cmp}.  The constant
ETag is provided by the request, and the symbolic one comes from the server
state.

\begin{figure}
\begin{coq}
  Notation sigma := (path -> resource).

  CoFixpoint server_http (state: sigma) :=
    pq <- trigger Recv;;
    let respond_with a :=
      trigger (Send { Source      := server_conn;
                      Destination := pq.(Source);
                      Payload     := inr a } ) in
    let q : request    := request_of pq        in
    let v : string     := q.(Content)          in
    let k : path       := q.(TargetPath)       in
    let t : string     := if_match q           in
    let tx: exp string := (state k).(ETag)     in
    IFX (Compare t tx Strong)
    THEN
      if q.(Method) is Put
      then
        tx' <- trigger Choice;;
        let state' := state [k |-> {Content := v; ETag := tx'}] in
        respond_with OK;;
        server_http state'
      else                 (* handling other kinds of requests *)
        (a, state') <- process q state;;
        respond_with a;;
        server_http state'
    ELSE
      respond_with PreconditionFailed;;
      server_http s.
\end{coq}
\caption{Server model for HTTP conditional requests}
\label{fig:if-match-server}
\end{figure}

\autoref{fig:if-match-server} shows an ITree model for If-Match requests 
(\autoref{sec:internal-nondeterminism}).  The server state \ilc{sigma} \lys{I
used \ilc{sigma} to represent the server state in QAC, so keeping this
notation.}  maps each path to its corresponding ``resource''---file content and
metadata like ETag.  The server first evaluates the request's \inlinec{If-Match}
condition by ``strong comparison'' as required by HTTP.  If the request's ETag
matches its target's, then the server updates the target's contents with the
request payload.  The target's new ETag \ilc{tx'} is permitted to be any value,
so the model represents it as \ilc{Choice} event.

Notice that the server model exhibits two kinds of branches: (1) The \ilc{if}
branches are provided by the ITree's embedding language Coq, which takes a
boolean value as condition; (2) The \ilc{IFX} branches are constructors of
ITrees with nondeterministic branches, where the condition is a symbolic
expression of type bool:
\begin{coq}
  Variant branchE: Type -> Type :=
    Decide: exp bool -> branchE bool.

  Notation "IFX condition THEN x ELSE y" :=
    (b <- trigger (Decide condition);;
     if b then x else y).
\end{coq}

These two kinds of branch conditions play different roles in the specification,
and will be handled differently during testing:
\begin{enumerate}
\item The ``pure'' \ilc{if} condition is used for deterministic branches like
  \ilc{(q.(Method) is Put)} in the example.  Here \ilc q is a ``concrete
  request''---a request that doesn't involve symbolic variables, as opposed to
  ``symbolic'' ones---generated by the client and sent to the server, so its
  method is known by the tester and needn't be symbolically evaluated.
\item The ``symbolic'' \ilc{IFX} condition here plays a similar rule as the
  $\mathsf{if}$ branches in the $\Prog$ language: Which branch to take depends
  on the server's internal choices, so the tester needs to consider both cases.
\end{enumerate}

Now we can instantiate the \ilc{qaE} type in \autoref{sec:qac-itree}.  The
symbolic server model receives concrete requests and sends symbolic responses,
so its event is defined as:
\begin{coq}
  Definition symbolic_packet := packet request symbolic_response.

  Variant qaE: Type -> Type :=
    Recv : qaE symbolic_packet
  | Send : symbolic_packet -> qaE unit.
\end{coq}

The HTTP server, for example, can be modelled as:
\begin{coq}
  Definition server_http: itree (qaE +' choiceE +' branchE) void :=
    server init_state.
\end{coq}

The server model is then transformed via network composition into a symbolic
model for test derivation purposes:
\begin{coq}
  (* Observer-side symbolic model's event type: *)
  Notation smE := (netE +' nondetE +' choiceE +' branchE).
  
  Definition sm_http: itree smE void :=
    compose server_http tcp [] [].
\end{coq}

This corresponds to the ``Symbolic Model'' in \autoref{fig:framework}.  The rest
of this section will explain the interpretations from this symbolic model.

\subsection{Dualizing symbolic model}
\label{sec:dualize-interaction}
This subsection takes the symbolic model composed in
\autoref{sec:symbolic-model} and dualizes its interactions, which corresponds
to the ``Dualization'' arrow in \autoref{fig:framework}.  It applies the idea of
derivation rules (\ref{rule:write})--(\ref{rule:return}) for $\Prog$
(\autoref{sec:dualize-prog}) to models written as ITrees.

This interpretation phase produces a symbolic observer that models the tester's
observation and validation behavior.  The observer sends a request when the
server wants to receive one, and receives a response when the server wants to
send one.  It also creates constraints over the server's internal choices based
on its observations.

\autoref{fig:symbolic-observer} shows the dualization algorithm.  It interprets
the symbolic model's events with the \ilc{observe} handler, whose types are
explained as follows:

\begin{figure}
\begin{lstlisting}[numbers=left]
Notation oE := (observeE +' nondetE +' choiceE +' constraintE).

Definition observe {R} (e: smE R) : itree oE R :=
  match e with
  | (Absorb |)     => trigger FromObserver%\label{line:observe-absorb}%
  | (Emit px|)     => p <- trigger ToObserver;;%\label{line:observe-emit}%
                      trigger (Guard px p)
  | (|||Branch bx) => or (trigger (Unify bx true);;  ret true)%\label{line:observe-branch}%
                         (trigger (Unify bx false);; ret false)
  | (|Or|)         => trigger Or%\label{line:observe-or}%
  | (||Choice|)    => trigger Choice%\label{line:observe-choice}%
  end.

Definition observer_http: itree oE void :=
  interp observe sm_http.
\end{lstlisting}
\caption{Dualizing symbolic model into symbolic observer.}
\label{fig:symbolic-observer}
\end{figure}

The tester observes a trace of concrete packets, so observer's interactions
return concrete requests and responses, as opposed to the symbolic model whose
responses are symbolic.
\begin{coq}
  Record concrete_packet := {
    source      : connection;
    destination : connection;
    payload     : request + concrete_response
  }.

  Variant observeE : Type -> Type :=
    FromObserver   : observeE concrete_packet
  | ToObserver     : observeE concrete_packet.
\end{coq}

Notice that the observer's send and receive events both return the packet sent
or received, unlike the server model whose \ilc{Send} event takes the sent
packet as argument.  This is because the tester needs to generate the request
packet to send, and the event's result value represents that generated and sent
packet.

As discussed in \autoref{sec:dualize-prog}, when the server sends a symbolic
response or branches over a symbolic condition, the tester needs to create
symbolic constraints accordingly.  The observer introduces ``constraint events''
for this derivation rule:
\begin{coq}
  Variant constraintE : Type -> Type :=
    Guard : packet -> concrete_packet -> constraintE unit
  | Unify : exp bool -> bool -> constraintE unit.
\end{coq}

Here \ilc{(Guard px p)} creates a constraint that the symbolic packet \ilc{px}
emitted by the specification matches the concrete packet \ilc p observed during
runtime.  \ilc{(Unify bx b)} creates a constraint that the symbolic branch
condition \ilc{bx} is unifiable with boolean value \ilc b.  These constraints
will be solved in \autoref{sec:symbolic-eval}.

The dualization algorithm in \autoref{fig:symbolic-observer} does the follows:
\begin{enumerate}
  \item When the symbolic model absorbs a packet in
    \autoref{line:observe-absorb}, the observer generates a request packet;
  \item When the symbolic model emits a symbolic packet \ilc{px} in
    \autoref{line:observe-emit}, the observer receives a concrete packet \ilc p,
    and adds a constraint that restricts the symbolic and concrete packets match
    each other.
  \item When the symbolic model branches on a symbolic condition \ilc{bx} in
    \autoref{line:observe-branch}, the tester accepts the observation if it can
    be explained by any branch.  This is done by constructing the observer as a
    nondeterministic program that has both branches, using the \ilc{or}
    combinator.  For each branch, the observer adds a constraint that the
    symbolic condition matches the chosen branch.
  \item Nondeterministic branches in \autoref{line:observe-or} are preserved in
    this interpretation phase, and will be resolved in \autoref{sec:backtrack}.
  \item Internal choices in \autoref{line:observe-choice} are addressed by the
    next phase in \autoref{sec:symbolic-eval}, along with the constraints
    created in this phase.
\end{enumerate}

The result of dualization is a symbolic observer that models the tester's
behavior like sending requests and receiving responses.  The symbolic observer
is a nondeterministic program with primitives events like making choices and
adding constraints over the choices.  The rest of this chapter instantiates the
primitive events and resolves the nondeterministic branches, and executes it as
an interactive tester.

\subsection{Symbolic evaluation}
\label{sec:symbolic-eval}
This subsection takes the symbolic observer produced in
\autoref{sec:dualize-interaction} and solves the constraints it has created.
The constraints unify symbolic packets and branch conditions against the
concrete observations.  The tester should accept the SUT if the constraints are
satisfiable.

\begin{figure}
\begin{lstlisting}[numbers=left]
Notation ntE := (observeE +' nondetE +' exceptE).

Definition V: Type := list var * list (constraintE unit).
  
Definition unify {R} (e: oE R) (v: V) : itree ntE (V * R) :=
  let (xs, cs) := v in
  match e with
  | (||Choice|)     => let x: var := fresh v in%\label{line:unify-choice}%
                       ret (x::xs, cs, Var x)
  | (|||constraint) => let cs' := constraint::cs in%\label{line:unify-constraint}%
                       if solvable cs'
                       then ret (xs, cs', tt)
                       else Trigger (Throw ("Conflict: " ++ print cs'))
  | (|Or|) => b <- trigger Or;; ret (v, b)%\label{line:unify-or}%
  | (oe|)  => r <- trigger oe;; ret (v, r)%\label{line:unify-observe}%
  end.

Definition nondet_tester_http: itree ntE void :=
  (_, vd) <- interp_state unify observer_http initV;;
  match vd in void with end.
\end{lstlisting}
\caption{Resolving symbolic constraints.}
\label{fig:nondet-tester}
\end{figure}

As shown in \autoref{fig:nondet-tester}, the unification algorithm evaluates the
primitive symbolic events into a stateful checker program, which reflects the
$\Prog$-based validator in \autoref{sec:dualize-prog}.  The interpretor
maintains a validation state \ilc V which stores the symbolic variables and the
constraints over them.  The derivation rules are as follows:
\begin{enumerate}
  \item When the server makes an internal choice in \autoref{line:unify-choice},
    the tester creates a fresh variable and adds it to the validation state.
  \item When the observer creates a constraint in
    \autoref{line:unify-constraint}, the tester adds the constraint to the
    validation state, and solves the new set of constraints.  If the constraints
    become unsatisfiable, then the tester \ilc{Throw}s an exception that
    indicates the current execution branch cannot accept the observations:
\begin{coq}
  Variable exceptE: Type -> Type :=
    Throw: forall {X}, string -> exceptE X.
\end{coq}      
  \item The observer is a nondeterministic program with multiple execution
    paths, constructed by \ilc{Or} events in \autoref{line:unify-or}.  The
    tester accepts the observation if any of the branches does not throw an
    exception.  These branches will be handled in the next section, along with
    the observer's send/receive interactions in \autoref{line:unify-observe}.
\end{enumerate}

Notice that the \ilc{unify} function interprets a symbolic observer's event
\ilc{(oE R)} into a state monad transformer \ilc{(V -> itree tE (V * R))}.  It
makes a step from pre-validation state \ilc{(v: V)} to post-validation state
\ilc{(v': V)}, and yields the event's corresponding result \ilc{(r: R)}.  Such
stateful interpretation process is handled by \ilc{interp_state}:
\begin{coq}
  CoFixpoint interp_state {E F V R}
                          (handler: forall {X}, E X -> V -> itree F (V * X))
                          (m: itree E R) (v: V)
             : itree F (V * R) :=
    match m with
    | Pure   r   => ret (v, r)
    | Impure e k => '(v', r) <- handler e v;;
                    interp_state handler (k r) v'
    end.
\end{coq}

So far I have interpreted the specification into a tester model that observes
incoming and outgoing packets, nondeterministically branches, and in some cases
throws exceptions.  The rest of this chapter will show how to execute this ITree
program on a deterministic machine and interact with the SUT.
