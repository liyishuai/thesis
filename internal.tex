This section applies the idea of dualization in \autoref{chap:dualize} to the
ITree context, showing how to address internal nondeterminism by symbolic
evaluation based on ITree specifications.  It covers the derivation path from
``symbolic model'' to ``nondeterministic tester'' in \autoref{fig:framework},
using \http entity tags introduced in \autoref{sec:internal-nondeterminism} as
an example.

As discussed in \autoref{sec:encode-spec}, dualization requires finer-grained
representation of the server's computation {\it e.g.} encoding its branches over
symbolic conditions.  This is done by designing ITrees' event types in
\autoref{sec:symbolic-model} and specifying the server's behavior with a
symbolic model.

The server specification is derived into a tester client by {\em interpreting}
interaction trees.  To interpret is to define semantic rules that transform one
ITree program into another, and corresponds to the arrows in
\autoref{fig:framework}.  \autoref{sec:interp} explains the interpretation of
ITrees.

The interpretation from symbolic model to the nondeterministic tester model is
implemented in two phases, illustrated as ``dualization'' and ``unification''
arrows in \autoref{fig:framework}: \autoref{sec:dualize-interaction} dualizes
the server's behavior into the tester client's, resulting in a ``symbolic
observer'' that encodes symbolic evaluation as primitive events.
\autoref{sec:symbolic-eval} then instantiates the primitive events into
pure computations that unify concrete observations against their symbolic
representations.

\subsection{Symbolic server model}
\label{sec:symbolic-model}

The key idea of language design is to expose symbolic representations to the
dualzation algorithm.  The $\Prog$ language in \autoref{sec:proglang} encodes
data as symbolic expressions $\Sexp$, so that the responses and branch
conditions may depend on internal choices.  I do the same for ITree
specifications, by symbolizing the choice events and branch conditions.  Take my
HTTP specification~\cite{issta21} as an example, its choice event has symbolic
expression as result type:

\begin{coq}
  Variant comparison := Strong | Weak.

  Variant exp: Type -> Type :=
    Const    : string -> exp string
  | Var      : var    -> exp string
  | Compare  : string -> exp string -> comparison -> exp bool.

  Variant choiceE: Type -> Type :=
    Choice: symE (exp string).
\end{coq}

Here I instantiate the \ilc{choiceE} in \autoref{sec:itree-lang} with symbolic
return type \ilc{(exp string)}, pronounced ``expression of type string''.  In
this example, I use strings to represent entity tags (ETags) that HTTP servers
may generate, which was discussed in \autoref{sec:internal-nondeterminism}.  The
type interface can be adjusted to other protocols under test.

Symbolic expressions may be constructed as constant values, as variables, or
with operators.  The \ilc{Compare} constructor takes an expression of type
string and compares it against a constant string.  \ilc{(Compare t tx cmp)}
represents the ETag comparison between \ilc{t} and \ilc{tx}, using ``strong
comparison'' or ``weak comparison'' mechanism~\cite{rfc7232} specified by
\ilc{cmp}.  The constant ETag is provided by the request, and the symbolized one
comes from the server state.

\begin{figure}
\begin{coq}
  Notation sigma := (path -> resource).

  CoFixpoint server_http (state: sigma) :=
    pq <- trigger Recv;;
    let respond_with a :=
      trigger (Send { Source      := server_conn;
                      Destination := pq.(Source);
                      Data        := a } ) in
    let q : request    := request_of pq    in
    let v : content    := q.(Payload)      in
    let k : path       := q.(TargetPath)   in
    let t : string     := if_match q       in
    let tx: exp string := (state k).(ETag) in
    IFX (Compare t tx Strong)
    THEN
      if q.(Method) is Put
      then
        tx' <- trigger Choice;;
        let state' := state [k |-> {Content := v; ETag := tx'}] in
        respond_with OK;;
        server_http state'
      else                 (* handling other kinds of requests *)
        (a, state') <- process q state;;
        respond_with a;;
        server_http state'
    ELSE
      respond_with PreconditionFailed;;
      server_http s.
\end{coq}
\caption{Server model for HTTP conditional requests}
\label{fig:if-match-server}
\end{figure}

\autoref{fig:if-match-server} shows an ITree model for If-Match requests in
\autoref{sec:internal-nondeterminism}.  The server first evaluates the request's
\inlinec{If-Match} condition by ``strong comparison'' as required by HTTP.  If
the request's ETag matches its target's, then the server updates the target's
contents with the request payload.  The target's new ETag \ilc{tx'} can be of
any value, so the model represents it as \ilc{Choice} event.

Notice that the server model exhibits two kinds of branches: (1) The \ilc{if}
branches are provided by the ITree's embedding language Coq, which takes a
boolean value as condition; (2) The \ilc{IFX} branches are constructors of
ITrees with nondeterministic branches, where the condition is a symbolic
expression of type bool:
\begin{coq}
  Variant branchE: Type -> Type :=
    Decide: exp bool -> branchE bool.

  Notation "IFX condition THEN x ELSE y" :=
    (b <- trigger (Decide condition);;
     if b then x else y).
\end{coq}

These two kinds of branch conditions play different roles in the specification,
and will be handled differently during testing:
\begin{enumerate}
\item The ``pure'' \ilc{if} condition is used for deterministic branches like
  \ilc{(q.(Method) is Put)} in the example.  Here \ilc q is a ``concrete
  request''\footnote{In this chapter, ``concrete'' messages are those that don't
    involve symbolic variables, as opposed to ``symbolic'' messages.} generated
  by the tester and sent to the server, so its method is known by the tester and
  needn't be symbolically evaluated.
\item The ``symbolic'' \ilc{IFX} condition here plays a similar rule as the
  $\mathsf{if}$ branches in the $\Prog$ language: Which branch to take depends
  on the server's internal choices, so the tester needs to consider both cases.
\end{enumerate}

Now we can fill the hole \ilc{\{E\}} in \autoref{fig:net-compose-code}.  The
server model receives concrete requests and sends symbolic responses, so its
event type is defined as:
\begin{coq}
  Record packet := {
    Source      : connection;
    Destination : connection;
    Data        : request + symbolic_response
  }.

  Variant qaE: Type -> Type :=
    Recv : qaE packet
  | Send : packet -> qaE unit.
\end{coq}

The HTTP server, for example, can be modelled as:
\begin{coq}
  Definition server_http: itree (qaE +' choiceE +' branchE) void :=
    server init_state.
\end{coq}

The server model is then transformed via network composition into a symbolic
model for test derivation purposes:
\begin{coq}
  (* Observer-side symbolic model's event type: *)
  Notation smE := (netE +' nondetE +' choiceE +' branchE).
  
  Definition sm_http: itree smE void :=
    compose server_http tcp [] [].
\end{coq}

This corresponds to the ``Symbolic Model'' in \autoref{fig:framework}.  The rest
of this section will explain the interpretations from this symbolic model.


\subsection{Interpreting interaction trees}
\label{sec:interp}
To interpret a program \ilc p is to specify a rule that defines ``if \ilc p does
this, then do that''.  For example, shell syntax \inlinec{(p < input > output)}
executes \inlinec p but redirects its standard I/O.  Suppose \inlinec p is the
\ilc{echo} program in \autoref{sec:itree-lang}, then the redirected program
should perform file operations specified in \ilc{redirect_echo}:
\begin{coq}
  Variant fileE: Type -> Type :=      (* file operation events *)
    Fgetc: file ->         fileE char
  | Fputc: file -> char -> fileE unit.

  CoInductive redirect_echo (input output: file) : itree fileE unit :=
    c <- trigger (Fgetc input);;
    if c is EOF then ret 0
    else trigger (Fputc output c);;
         redirect_echo input output.
\end{coq}

When redirecting a program's standard I/O to files, the interpretation rule is
``whenever the program wants to read from or write to standard I/O, perform the
read/write operation on the specified file instead'':
\begin{coq}
  Definition redirect (input output: file) {R: Type} (e: stdioE R) :=
    match e in stdioE R return itree fileE R with
    | GetChar   => trigger (Fgetc input)
    | PutChar c => trigger (Fputc output c)
    end.
\end{coq}

Here the \ilc{redirect} function takes a standard I/O event and turns it into an
ITree program that performs file events.  The result program has the same return
type as the original event, so it can ``replace'' the original \ilc{stdioE}.
This is done by the \ilc{interp} function:
\begin{coq}
  CoFixpoint interp {E F R} (f: forall {T}, E T -> itree F T) (m: itree E R)
             : itree F R :=
    match m with
    | Pure   r   => Pure r
    | Impure e k => x <- f e;;
                    interp handler (k x)
    end.

  Definition redirect_echo2 (input output: file) : itree fileE unit :=
    interp (redirect input output) (translateM echo).
\end{coq}

For each impure event, the interpretor replaces it with the program defined by
the handler function \ilc f.  As a result, \ilc{redirect_echo2} constructs a
redirected echo program that is equivalent with \ilc{redirect_echo}.

To derive tester programs from ITree specifications, I'll introduce multiple
interpretation processes, with various event handlers throughout this chapter.


\subsection{Dualizing interactions}
\label{sec:dualize-interaction}
This subsection takes the symbolic model composed in
\autoref{sec:symbolic-model} and dualizes its interactions, which corresponds to
the ``Dualization'' arrow in \autoref{fig:framework}.  It applies the derivation
rules (\ref{rule:write})--(\ref{rule:return}) for $\Prog$ in
\autoref{sec:dualize-prog} to models written as ITrees.

This interpretation phase produces a symbolic observer that models the tester's
observation and validation behavior.  The observer sends a request when the
server wants to receive one, and receives a response when the server wants to
send one.  It also creates constraints over the server's internal choices based
on its observations.

\autoref{fig:symbolic-observer} shows the dualization algorithm.  It interprets
the symbolic model's events with the \ilc{observe} handler, whose types are
explained as follows:

\begin{figure}
\begin{lstlisting}[numbers=left]
Notation oE := (observeE +' nondetE +' choiceE +' constraintE).

Definition observe {R} (e: smE R) : itree oE R :=
  match e with
  | (Absorb |)     => trigger FromObserver%\label{line:observe-absorb}%
  | (Emit px|)     => p <- trigger ToObserver;;%\label{line:observe-emit}%
                      trigger (Guard px p)
  | (|||Branch bx) => or (trigger (Unify bx true);;  ret true)%\label{line:observe-branch}%
                         (trigger (Unify bx false);; ret false)
  | (|Or|)         => trigger Or%\label{line:observe-or}%
  | (||Choice|)    => trigger Choice%\label{line:observe-choice}%
  end.

Definition observer_http: itree oE void :=
  interp observe sm_http.
\end{lstlisting}
\caption{Dualizing symbolic model into symbolic observer.}
\label{fig:symbolic-observer}
\end{figure}

The tester observes a trace of concrete packets, so observer's interactions
return concrete requests and responses, as opposed to the symbolic model whose
responses are symbolic.
\begin{coq}
  Record concrete_packet := {
    source      : connection;
    destination : connection;
    payload     : request + concrete_response
  }.

  Variant observeE : Type -> Type :=
    FromObserver   : observeE concrete_packet
  | ToObserver     : observeE concrete_packet.
\end{coq}

Notice that the observer's send and receive events both return the packet sent
or received, unlike the server model whose \ilc{Send} event takes the sent
packet as argument.  This is because the tester needs to generate the request
packet to send, and the event's result value represents that generated and sent
packet.

As discussed in \autoref{sec:dualize-prog}, when the server sends a symbolic
response or branches over a symbolic condition, the tester needs to create
symbolic constraints accordingly.  The observer introduces ``constraint events''
for this derivation rule:
\begin{coq}
  Variant constraintE : Type -> Type :=
    Guard : packet -> concrete_packet -> constraintE unit
  | Unify : exp bool -> bool -> constraintE unit.
\end{coq}

Here \ilc{(Guard px p)} creates a constraint that the symbolic packet \ilc{px}
emitted by the specification matches the concrete packet \ilc p observed during
runtime.  \ilc{(Unify bx b)} creates a constraint that the symbolic branch
condition \ilc{bx} is unifiable with boolean value \ilc b.  These constraints
will be solved in \autoref{sec:symbolic-eval}.

The dualization algorithm in \autoref{fig:symbolic-observer} does the follows:
\begin{enumerate}
  \item When the symbolic model absorbs a packet in
    \autoref{line:observe-absorb}, the observer generates a request packet;
  \item When the symbolic model emits a symbolic packet \ilc{px} in
    \autoref{line:observe-emit}, the observer receives a concrete packet \ilc p,
    and adds a constraint that restricts the symbolic and concrete packets match
    each other.
  \item When the symbolic model branches on a symbolic condition \ilc{bx} in
    \autoref{line:observe-branch}, the tester accepts the observation if it can
    be explained by any branch.  This is done by constructing the observer as a
    nondeterministic program that has both branches, using the \ilc{or}
    combinator.  For each branch, the observer adds a constraint that the
    symbolic condition matches the chosen branch.
  \item Nondeterministic branches in \autoref{line:observe-or} are preserved in
    this interpretation phase, and will be resolved in \autoref{sec:backtrack}.
  \item Internal choices in \autoref{line:observe-choice} are addressed by the
    next phase in \autoref{sec:symbolic-eval}, along with the constraints
    created in this phase.
\end{enumerate}

The result of dualization is a symbolic observer that models the tester's
behavior like sending requests and receiving responses.  The symbolic observer
is a nondeterministic program with primitives events like making choices and
adding constraints over the choices.  The rest of this chapter instantiates the
primitive events and resolves the nondeterministic branches, and executes it as
an interactive tester.

\subsection{Symbolic evaluation}
\label{sec:symbolic-eval}
This subsection takes the symbolic observer produced in
\autoref{sec:dualize-interaction} and solves the constraints it has created.
The constraints unify symbolic packets and branch conditions against the
concrete observations.  The tester should accept the SUT if the constraints are
satisfiable.

\begin{figure}
\begin{lstlisting}[numbers=left]
Notation ntE := (observeE +' nondetE +' exceptE).

Definition V: Type := list var * list (constraintE unit).
  
Definition unify {R} (e: oE R) (v: V) : itree ntE (V * R) :=
  let (xs, cs) := v in
  match e with
  | (||Choice|)     => let x: var := fresh v in%\label{line:unify-choice}%
                       ret (x::xs, cs, Var x)
  | (|||constraint) => let cs' := constraint::cs in%\label{line:unify-constraint}%
                       if solvable cs'
                       then ret (xs, cs', tt)
                       else Trigger (Throw ("Conflict: " ++ print cs'))
  | (|Or|) => b <- trigger Or;; ret (v, b)%\label{line:unify-or}%
  | (oe|)  => r <- trigger oe;; ret (v, r)%\label{line:unify-observe}%
  end.

Definition nondet_tester_http: itree ntE void :=
  (_, vd) <- interp_state unify observer_http initV;;
  match vd in void with end.
\end{lstlisting}
\caption{Resolving symbolic constraints.}
\label{fig:nondet-tester}
\end{figure}

As shown in \autoref{fig:nondet-tester}, the unification algorithm evaluates the
primitive symbolic events into a stateful checker program, which reflects the
$\Prog$-based validator in \autoref{sec:dualize-prog}.  The interpretor
maintains a validation state \ilc V which stores the symbolic variables and the
constraints over them.  The derivation rules are as follows:
\begin{enumerate}
  \item When the server makes an internal choice in \autoref{line:unify-choice},
    the tester creates a fresh variable and adds it to the validation state.
  \item When the observer creates a constraint in
    \autoref{line:unify-constraint}, the tester adds the constraint to the
    validation state, and solves the new set of constraints.  If the constraints
    become unsatisfiable, then the tester \ilc{Throw}s an exception that
    indicates the current execution branch cannot accept the observations:
\begin{coq}
  Variable exceptE: Type -> Type :=
    Throw: forall {X}, string -> exceptE X.
\end{coq}      
  \item The observer is a nondeterministic program with multiple execution
    paths, constructed by \ilc{Or} events in \autoref{line:unify-or}.  The
    tester accepts the observation if any of the branches does not throw an
    exception.  These branches will be handled in the next section, along with
    the observer's send/receive interactions in \autoref{line:unify-observe}.
\end{enumerate}

Notice that the \ilc{unify} function interprets a symbolic observer's event
\ilc{(oE R)} into a state monad transformer \ilc{(V -> itree tE (V * R))}.  It
makes a step from pre-validation state \ilc{(v: V)} to post-validation state
\ilc{(v': V)}, and yields the event's corresponding result \ilc{(r: R)}.  Such
stateful interpretation process is handled by \ilc{interp_state}:
\begin{coq}
  CoFixpoint interp_state {E F V R}
                          (handler: forall {X}, E X -> V -> itree F (V * X))
                          (m: itree E R) (v: V)
             : itree F (V * R) :=
    match m with
    | Pure   r   => ret (v, r)
    | Impure e k => '(v', r) <- handler e v;;
                    interp_state handler (k r) v'
    end.
\end{coq}

So far I have interpreted the specification into a tester model that observes
incoming and outgoing packets, nondeterministically branches, and in some cases
throws exceptions.  The rest of this chapter will show how to execute this ITree
program on a deterministic machine and interact with the SUT.
