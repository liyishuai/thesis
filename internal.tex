This section applies the dualization theory in \autoref{chap:theory} to the
ITree context.  I'll show how to perform symbolic evaluation by interpreting
ITree programs.

\autoref{sec:symbolic-model} explains how to represent systems' internal choices
as ITree's symbolic events.  It fills in the \ilc{\{E\}} hole in
\autoref{fig:net-compose-code}, and constructs the ``Symbolic Model'' box in
\autoref{fig:framework}.  \autoref{sec:dualize-interaction} and
\autoref{sec:symbolic-eval} takes the observer-side specification composed in
\autoref{sec:net-compose} and interprets it into a tester model, covering the
``Dualization'' and ``Unification'' arrows in the derivation framework.

\subsection{Symbolizing internal choices}
\label{sec:symbolic-model}
The key idea of language design is to expose symbolic representations to the
dualzation algorithm.  The $\Prog$ language in \autoref{sec:proglang} encodes
data as symbolic expressions $\Sexp$, so that the responses and branch
conditions may depend on internal choices.  I do the same for ITree
specifications, by symbolizing the choice events and branch conditions.  Take my
HTTP specification~\cite{issta21} as an example, its choice event has symbolic
expression as result type:

\begin{coq}
  Variant comparison := Strong | Weak.

  Variant exp: Type -> Type :=
    Const    : string -> exp string
  | Var      : var    -> exp string
  | Compare  : string -> exp string -> comparison -> exp bool.

  Variant choiceE: Type -> Type :=
    Choice: symE (exp string).
\end{coq}

Here I instantiate the \ilc{choiceE} in \autoref{sec:itree-lang} with symbolic
return type \ilc{(exp string)}, pronounced ``expression of type string''.  In
this example, I use strings to represent entity tags (ETags) that HTTP servers
may generate, which was discussed in \autoref{sec:internal-nondeterminism}.  The
type interface can be adjusted to other protocols under test.

Symbolic expressions may be constructed as constant values, as variables, or
with operators.  The \ilc{Compare} constructor takes an expression of type
string and compares it against a constant string.  \ilc{(Compare t tx cmp)}
represents the ETag comparison between \ilc{t} and \ilc{tx}, using ``strong
comparison'' or ``weak comparison'' mechanism~\cite{rfc7232} specified by
\ilc{cmp}.  The constant ETag is provided by the request, and the symbolized one
comes from the server state.

\begin{figure}
\begin{coq}
  CoFixpoint server (state: path -> resource) :=
    q <- trigger Recv;;
    let v : content    := q.(Payload)      in
    let k : path       := q.(TargetPath)   in
    let t : string     := q.(IfMatch)      in
    let tx: exp string := (state k).(ETag) in
    IFX (Compare t tx Strong)
    THEN
      if q.(Method) is Put
      then
        tx' <- trigger Choice;;
        let state' := state [k |-> {Content := v; ETag := tx'}] in
        trigger (Send OK);;
        server state'
      else                 (* handling other kinds of requests *)
        (a, state') <- process q state;;
        trigger (Send a);;
        server state'
    ELSE
      trigger (Send PreconditionFailed);;
      server s.
\end{coq}
\caption{Server model for HTTP conditional requests}
\label{fig:if-match-server}
\end{figure}

\autoref{fig:if-match-server} shows an ITree model for If-Match requests in
\autoref{sec:internal-nondeterminism}.  The server first evaluates the request's
\inlinec{If-Match} condition by ``strong comparison'' as required by HTTP.  If
the request's ETag matches its target's, then the server updates the target's
contents with the request payload.  The target's new ETag \ilc{tx'} can be of
any value, so the model represents it as \ilc{Choice} event.

Notice that the server model exhibits two kinds of branches: (1) The \ilc{if}
branches are provided by the ITree's embedding language Coq, which takes a
boolean value as condition; (2) The \ilc{IFX} branches are constructors of
ITrees with nondeterministic branches, where the condition is a symbolic
expression of type bool:
\begin{coq}
  Variant branchE: Type -> Type :=
    Decide: exp bool -> branchE bool.

  Notation "IFX condition THEN x ELSE y" :=
    (b <- trigger (Decide condition);;
     if b then x else y).
\end{coq}

These two kinds of branch conditions play different roles in the specification,
and will be handled differently during testing:
\begin{enumerate}
\item The ``pure'' \ilc{if} condition is used for deterministic branches like
  \ilc{(q.(Method) is Put)} in the example.  Here the request \ilc q is
  generated by the tester and sent to the server, so its method is known by the
  tester and needn't be symbolically evaluated.
\item The ``symbolic'' \ilc{IFX} condition here plays a similar rule as the
  $\mathsf{if}$ branches in the $\Prog$ language: Which branch to take depends
  on the server's internal choices, so the tester needs to consider both cases.
\end{enumerate}

Now we can fill the whole \ilc{\{E\}} in \autoref{fig:net-compose-code}.  The
HTTP server can be modelled as, for example:
\begin{coq}
  Definition server_http: itree (qaE +' choiceE +' branchE) void :=
    server init_state.
\end{coq}

The server model is then transformed via network composition into a symbolic
model for test derivation purposes:
\begin{coq}
  Definition sm_http: itree (netE +' nondetE +' choiceE +' branchE) void :=
    compose server_http tcp [] [].
\end{coq}

This corresponds to the ``Symbolic Model'' in \autoref{fig:framework}.  The rest
of this section will explain the interpretations from this symbolic model.

\subsection{Dualizing interactions}
\label{sec:dualize-interaction}
This subsection takes the symbolic model composed in
\autoref{sec:symbolic-model} and dualizes its interactions.  It shares the basic
idea with the simplistic \ilc{tester} in \autoref{sec:interactive-testing}, and
adds mechanisms to handle internal and external nondeterminism.




\subsection{Symbolic evaluation}
\label{sec:symbolic-eval}
